Attention: The following text is a 'bfiles' bundle, containing multiple delimited files with metadata.
Parse and analyze the content between '<<< BOF <<<' and '>>> EOF >>>' for each '### FILE...' entry.

--- START OF BFILE bf-20251129-152706.txt ---
bfiles bundle generated on: 2025-11-29T15:27:06.245729
Config: hash=sha256, gitignore=yes, followlinks=no
---

### FILE 1: api/codec.md | checksum=05bce2849a84... | modified=2025-11-15T19:17:59 | op=+ | size=1434 | tokens=312 | type=markdown ###
<<< BOF <<<
# Codec API

The `pyvider.cty.codec` module provides serialization and deserialization capabilities for `CtyValue` instances, enabling cross-language compatibility with go-cty and efficient binary storage.

Key functions:
- **`cty_to_msgpack(value, type)`** - Serialize a `CtyValue` to MessagePack binary format
- **`cty_from_msgpack(data, type)`** - Deserialize MessagePack binary data back to a `CtyValue`

**MessagePack Format**: The MessagePack serialization format is **fully compatible** with HashiCorp's go-cty library, enabling true cross-language data exchange. This is the recommended format for interoperability with Terraform providers and other Go-based tools.

**JSON Support**: For JSON encoding/decoding, use the `jsonencode()` and `jsondecode()` functions from `pyvider.cty.functions`. These operate on `CtyValue` objects and return `CtyValue` objects containing JSON strings, rather than providing direct serialization/deserialization.

**Type Preservation**: MessagePack serialization preserves type information, null values, unknown values, and marks, ensuring complete fidelity when round-tripping data.

For detailed serialization documentation, see: **[User Guide: Serialization](../user-guide/advanced/serialization.md)**

---

::: pyvider.cty.codec
    options:
      show_source: true
      show_root_heading: true
      members_order: source
      show_if_no_docstring: false
      filters:
        - "!^_"
>>> EOF >>>

### FILE 2: api/context.md | checksum=99439ce0dfab... | modified=2025-11-15T19:17:59 | op=+ | size=4468 | tokens=949 | type=markdown ###
<<< BOF <<<
# CTY Context

The `pyvider.cty.context` module provides utilities for tracking validation depth during type operations.

Key components:
- **`deeper_validation()`** - Context manager to safely increment and decrement validation depth
- **`get_validation_depth()`** - Returns the current validation depth
- **`MAX_VALIDATION_DEPTH`** - Configurable maximum depth limit (default: 500 levels)
- **Context-local state** - Validation depth is stored per-context using `contextvars` for thread and async safety

The context system is used internally by the validation system to track nesting depth. You typically won't interact with it directly unless you're:
- Implementing custom types that need to participate in depth tracking
- Adjusting validation depth limits for extremely deep structures
- Debugging validation behavior

The context automatically tracks how deep the validation has recursed into nested structures and raises an error if the maximum depth is exceeded, protecting against malicious or malformed data that could cause stack overflow.

## Usage Examples

### Checking Current Validation Depth

```python
from pyvider.cty.context import get_validation_depth, MAX_VALIDATION_DEPTH

# Get current depth (defaults to 0 outside validation)
depth = get_validation_depth()
print(f"Current depth: {depth}")
print(f"Maximum allowed depth: {MAX_VALIDATION_DEPTH}")
```

### Using Depth Tracking in Custom Validation

```python
from pyvider.cty.context import deeper_validation, get_validation_depth
from pyvider.cty import CtyObject, CtyString, CtyList

# When implementing custom validation logic
def validate_nested_structure(data, depth_limit=10):
    """Custom validation with depth tracking."""
    current_depth = get_validation_depth()

    if current_depth > depth_limit:
        raise ValueError(f"Exceeded custom depth limit: {depth_limit}")

    with deeper_validation():
        # Validation depth is now current_depth + 1
        # Process nested data here
        pass

# Example: Validating deeply nested structures
nested_type = CtyObject(
    attribute_types={
        "name": CtyString(),
        "children": CtyList(element_type=CtyString())
    }
)

data = {"name": "root", "children": ["child1", "child2"]}
validated = nested_type.validate(data)
```

### Understanding Depth Limits

```python
from pyvider.cty import CtyObject, CtyList, CtyString
from pyvider.cty.context import MAX_VALIDATION_DEPTH

# The default MAX_VALIDATION_DEPTH is 500
# This prevents stack overflow with extremely deep nesting

# Example of structure that would hit depth limits:
def create_deeply_nested_data(depth):
    """Create nested dict with specified depth."""
    if depth == 0:
        return {"value": "leaf"}
    return {"nested": create_deeply_nested_data(depth - 1)}

# This would succeed (within limit)
shallow_data = create_deeply_nested_data(10)

# This would fail if depth > MAX_VALIDATION_DEPTH
try:
    very_deep_data = create_deeply_nested_data(600)
    # Attempting to validate would raise depth error
except RecursionError:
    print("Depth limit exceeded")
```

### Thread and Async Safety

The context system uses `contextvars` for thread-local and async-safe state management:

```python
import asyncio
from pyvider.cty import CtyString
from pyvider.cty.context import get_validation_depth

async def validate_in_context():
    """Validation depth is isolated per async context."""
    string_type = CtyString()

    # Each async context has its own validation depth
    depth = get_validation_depth()
    value = string_type.validate("test")

    return value

# Multiple concurrent validations don't interfere
async def main():
    results = await asyncio.gather(
        validate_in_context(),
        validate_in_context(),
        validate_in_context()
    )
    # Each had independent depth tracking

# asyncio.run(main())
```

## Related Documentation

- **[User Guide: Validation](../user-guide/core-concepts/validation.md)** - Comprehensive validation documentation
- **[Configuration](../reference/configuration.md)** - Configuration options including validation depth limits
- **[Troubleshooting: Recursion Depth](../reference/troubleshooting.md#scenario-5-recursion-depth-exceeded)** - Handling depth limit errors

---

::: pyvider.cty.context
    options:
      show_source: true
      show_root_heading: true
      members_order: source
      show_if_no_docstring: false
      filters:
        - "!^_"
        - "^__init__$"
>>> EOF >>>

### FILE 3: api/conversion.md | checksum=afb0406f87d3... | modified=2025-11-15T19:17:59 | op=+ | size=1310 | tokens=282 | type=markdown ###
<<< BOF <<<
# CTY Conversion

The `pyvider.cty.conversion` module provides type conversion and unification capabilities for transforming values between different cty types.

Key functions:
- **`convert(value, target_type)`** - Convert a `CtyValue` to a different type when possible (e.g., number to string, string to number)
- **`unify(types)`** - Find the most specific type that can represent all given types (type unification)

**Conversion vs Validation**: Conversion is more flexible than validation - it attempts to transform values between compatible types, while validation strictly checks conformance to a type schema. For example, `convert(CtyString().validate("123"), CtyNumber())` succeeds and returns the number 123, while `CtyNumber().validate("123")` fails because the input is not already a number.

Type conversion is essential for building flexible APIs that accept multiple input formats and for implementing polymorphic functions that work across different types.

For detailed conversion documentation, see: **[User Guide: Type Conversion](../user-guide/core-concepts/conversion.md)**

---

::: pyvider.cty.conversion
    options:
      show_source: true
      show_root_heading: true
      members_order: source
      show_if_no_docstring: false
      filters:
        - "!^_"
        - "^__init__$"
>>> EOF >>>

### FILE 4: api/functions.md | checksum=19356df220dd... | modified=2025-11-15T19:17:59 | op=+ | size=1280 | tokens=292 | type=markdown ###
<<< BOF <<<
# CTY Functions

The `pyvider.cty.functions` module provides a comprehensive standard library of type-safe functions for manipulating `CtyValue` instances. All functions operate on `CtyValue` objects and return new `CtyValue` objects, maintaining immutability throughout.

Functions are organized into categories:
- **Numeric** - Mathematical operations (add, multiply, abs_fn, ceil_fn, etc.)
- **String** - Text manipulation (upper, lower, trim, split, regex, etc.)
- **Collection** - List and map operations (concat, flatten, keys, values, etc.)
- **Comparison** - Value comparisons (equal, greater_than, less_than, etc.)
- **Conversion** - Type conversions (to_string, to_number, to_bool)
- **Encoding** - Serialization (jsonencode, jsondecode, csvdecode)
- **Date/Time** - Timestamp operations (formatdate, timeadd)

All functions perform proper null and unknown value handling, propagating these special states through operations as appropriate.

For a complete overview with descriptions, see: **[User Guide: Functions](../user-guide/advanced/functions.md)**

---

::: pyvider.cty.functions
    options:
      show_source: true
      show_root_heading: true
      members_order: source
      show_if_no_docstring: false
      filters:
        - "!^_"
        - "^__init__$"
>>> EOF >>>

### FILE 5: api/index.md | checksum=63f08cab94d4... | modified=2025-11-15T19:17:59 | op=+ | size=4245 | tokens=1010 | type=markdown ###
<<< BOF <<<
# API Reference

Welcome to the complete API reference for pyvider.cty. This section provides detailed documentation for all public classes, functions, and modules in the library.

## Module Organization

The pyvider.cty API is organized into the following modules:

### Core Modules

- **[Types](types/index.md)** - Type system implementation (primitives, collections, structural, capsule)
  - [Primitive Types](types/primitives.md) - `CtyString`, `CtyNumber`, `CtyBool`
  - [Collection Types](types/collections.md) - `CtyList`, `CtyMap`, `CtySet`
  - [Structural Types](types/structural.md) - `CtyObject`, `CtyTuple`, `CtyDynamic`
  - [Capsule Types](types/capsule.md) - `CtyCapsule`, `CtyCapsuleWithOps`

- **[Values](values.md)** - `CtyValue` class for immutable, type-safe data instances

- **[Conversion](conversion.md)** - Type conversion and unification functions
  - `convert(value, target_type)` - Convert between types
  - `unify(types)` - Find the most specific common type

### Serialization & Encoding

- **[Codec](codec.md)** - MessagePack serialization for cross-language compatibility
  - `cty_to_msgpack()` - Serialize to binary format
  - `cty_from_msgpack()` - Deserialize from binary format

- **[Functions](functions.md)** - Standard library of built-in functions
  - String manipulation, numeric operations, collection functions
  - Type conversions, encoding/decoding, date/time operations

### Advanced Features

- **[Path Navigation](path.md)** - Navigate nested structures with `CtyPath`
  - `GetAttrStep`, `IndexStep`, `KeyStep`

- **[Parser](parser.md)** - Terraform type string parsing
  - `parse_tf_type_to_ctytype()` - Parse Terraform type specifications
  - `parse_type_string_to_ctytype()` - Alias for backward compatibility

- **[Validation](validation.md)** - Recursion detection and validation utilities
  - Recursion context management
  - Cycle detection decorators

- **[Context](context.md)** - Validation depth tracking
  - Context-local state management
  - Depth limit protection

## Quick Reference

### Importing Types

```python
from pyvider.cty import (
    CtyString, CtyNumber, CtyBool,      # Primitives
    CtyList, CtyMap, CtySet,            # Collections
    CtyObject, CtyTuple, CtyDynamic,    # Structural
    CtyCapsule, CtyCapsuleWithOps,      # Capsule
    CtyType, CtyValue,                   # Base classes
)
```

### Importing Utilities

```python
from pyvider.cty import convert, unify              # Conversion
from pyvider.cty import CtyMark                     # Marks
from pyvider.cty.codec import (                     # Serialization
    cty_to_msgpack, cty_from_msgpack
)
from pyvider.cty.functions import (                 # Functions
    jsonencode, jsondecode,
    upper, lower, concat,
    # ... and many more
)
```

### Importing Exceptions

```python
from pyvider.cty import (
    CtyValidationError,                # General validation
    CtyConversionError,                # Type conversion
    CtyAttributeValidationError,       # Object attributes
    CtyListValidationError,            # List validation
    CtyMapValidationError,             # Map validation
    CtySetValidationError,             # Set validation
    CtyTupleValidationError,           # Tuple validation
    CtyTypeMismatchError,              # Type mismatches
    CtyTypeParseError,                 # Type string parsing
)
```

## Documentation Notes

- **Auto-generated sections**: Some API sections are auto-generated from source code docstrings
- **Type hints**: All functions include complete type annotations
- **Examples**: Most API functions include usage examples
- **Related guides**: Each API section links to related user guide chapters

## Additional Resources

- **[User Guide](../user-guide/index.md)** - Comprehensive feature documentation
- **[How-To Guides](../how-to/index.md)** - Task-oriented guides
- **[Getting Started](../getting-started/index.md)** - Quick introduction
- **[Examples](../getting-started/examples.md)** - Runnable code examples

---

# PyVider CTY API

::: pyvider.cty
    options:
      show_source: true
      show_root_heading: true
      members_order: source
      show_if_no_docstring: false
      filters:
        - "!^_"
        - "^__init__$"
>>> EOF >>>

### FILE 6: api/parser.md | checksum=f1546413035c... | modified=2025-11-15T19:17:59 | op=+ | size=5972 | tokens=1565 | type=markdown ###
<<< BOF <<<
# Type Parsing

The `pyvider.cty.parser` module provides functions for parsing Terraform type strings and JSON type specifications into `pyvider.cty` type objects.

## Parser Functions

### `parse_tf_type_to_ctytype()`

Parses a Terraform type constraint (as a Python object or string) into a `CtyType` instance.

**Signature:**
```python
def parse_tf_type_to_ctytype(tf_type: Any) -> CtyType[Any]
```

**Parameters:**
- `tf_type`: A Terraform type specification, which can be:
  - A string for primitive types: `"string"`, `"number"`, `"bool"`, `"dynamic"`
  - A list with two elements `[type_kind, type_spec]` for collections and structural types
  - A nested structure for complex types

**Returns:**
- A `CtyType` instance corresponding to the Terraform type

**Raises:**
- `CtyValidationError`: If the type specification is invalid

**Examples:**

```python
from pyvider.cty.parser import parse_tf_type_to_ctytype

# Primitive types
string_type = parse_tf_type_to_ctytype("string")
number_type = parse_tf_type_to_ctytype("number")
bool_type = parse_tf_type_to_ctytype("bool")
dynamic_type = parse_tf_type_to_ctytype("dynamic")

# Collection types (JSON array format)
list_type = parse_tf_type_to_ctytype(["list", "string"])
map_type = parse_tf_type_to_ctytype(["map", "number"])
set_type = parse_tf_type_to_ctytype(["set", "bool"])

# Object type
object_type = parse_tf_type_to_ctytype([
    "object",
    {
        "name": "string",
        "age": "number",
        "active": "bool"
    }
])

# Tuple type
tuple_type = parse_tf_type_to_ctytype([
    "tuple",
    ["string", "number", "bool"]
])

# Nested types
nested_type = parse_tf_type_to_ctytype([
    "list",
    ["object", {"id": "string", "value": "number"}]
])
```

### `parse_type_string_to_ctytype()`

**Alias for `parse_tf_type_to_ctytype()`**

This function is an alias to `parse_tf_type_to_ctytype()` and provides identical functionality. Both names are available for backward compatibility and user preference.

```python
from pyvider.cty.parser import parse_type_string_to_ctytype

# Same as parse_tf_type_to_ctytype()
string_type = parse_type_string_to_ctytype("string")
```

**Note**: Use `parse_tf_type_to_ctytype()` for clarity, as it explicitly indicates the function parses Terraform type specifications.

## Type Specification Format

Terraform uses a JSON-based format to represent types:

### Primitive Types

Represented as strings:
- `"string"` ‚Üí `CtyString()`
- `"number"` ‚Üí `CtyNumber()`
- `"bool"` ‚Üí `CtyBool()`
- `"dynamic"` ‚Üí `CtyDynamic()`

### Collection Types

Represented as `[kind, element_type]`:
- `["list", "string"]` ‚Üí `CtyList(element_type=CtyString())`
- `["set", "number"]` ‚Üí `CtySet(element_type=CtyNumber())`
- `["map", "bool"]` ‚Üí `CtyMap(element_type=CtyBool())`

### Structural Types

**Object**: `["object", {...}]`
```python
["object", {
    "attr1": "string",
    "attr2": "number"
}]
```

**Tuple**: `["tuple", [...]]`
```python
["tuple", ["string", "number", "bool"]]
```

## Integration with Terraform

These parser functions are essential for working with Terraform:

### Parsing Variable Types

```python
from pyvider.cty.parser import parse_tf_type_to_ctytype

# Terraform variable block:
# variable "vpc_config" {
#   type = object({
#     cidr = string
#     region = string
#   })
# }

# Parse the type
vpc_type = parse_tf_type_to_ctytype([
    "object",
    {
        "cidr": "string",
        "region": "string"
    }
])

# Validate data
vpc_data = {
    "cidr": "10.0.0.0/16",
    "region": "us-east-1"
}

vpc_value = vpc_type.validate(vpc_data)
```

### Parsing Resource Schemas

```python
# Terraform resource schema
resource_schema_json = [
    "object",
    {
        "name": "string",
        "instance_type": "string",
        "tags": ["map", "string"]
    }
]

resource_type = parse_tf_type_to_ctytype(resource_schema_json)

# Use for validation
resource_config = {
    "name": "web-server",
    "instance_type": "t2.micro",
    "tags": {"Environment": "production"}
}

validated_config = resource_type.validate(resource_config)
```

## Error Handling

The parser raises `CtyValidationError` for invalid type specifications:

```python
from pyvider.cty.parser import parse_tf_type_to_ctytype
from pyvider.cty.exceptions import CtyValidationError

try:
    # Invalid: unknown primitive type
    invalid_type = parse_tf_type_to_ctytype("invalid_type")
except CtyValidationError as e:
    print(f"Parse error: {e}")

try:
    # Invalid: object spec must be a dict
    invalid_object = parse_tf_type_to_ctytype(["object", "not_a_dict"])
except CtyValidationError as e:
    print(f"Parse error: {e}")
```

## Common Patterns

### Parsing from JSON Configuration

```python
import json
from pyvider.cty.parser import parse_tf_type_to_ctytype

# Load type specification from JSON file
with open("schema.json") as f:
    type_spec = json.load(f)

# Parse to CtyType
schema = parse_tf_type_to_ctytype(type_spec)
```

### Dynamic Schema Loading

```python
def load_schema(schema_name: str) -> CtyType:
    """Load a schema by name from configuration."""
    schemas = {
        "user": ["object", {"name": "string", "email": "string"}],
        "post": ["object", {"title": "string", "content": "string"}],
    }

    if schema_name not in schemas:
        raise ValueError(f"Unknown schema: {schema_name}")

    return parse_tf_type_to_ctytype(schemas[schema_name])

# Use it
user_type = load_schema("user")
post_type = load_schema("post")
```

## See Also

- **[Terraform Interoperability](../user-guide/advanced/terraform-interop.md)** - Working with Terraform types
- **[How to Work with Terraform](../how-to/work-with-terraform.md)** - Practical Terraform integration
- **[Types API](types/index.md)** - Type system reference

---

::: pyvider.cty.parser
    options:
      show_source: true
      show_root_heading: true
      members_order: source
      show_if_no_docstring: false
      filters:
        - "!^_"
        - "^__init__$"
>>> EOF >>>

### FILE 7: api/path.md | checksum=4135d7b36f58... | modified=2025-11-15T19:17:59 | op=+ | size=1202 | tokens=265 | type=markdown ###
<<< BOF <<<
# CTY Path

The `pyvider.cty.path` module provides type-safe navigation through nested data structures using path expressions.

Key components:
- **`CtyPath`** - Represents a path through a nested structure as a sequence of steps
- **`GetAttrStep`** - Navigate to an object attribute by name
- **`IndexStep`** - Navigate to a list/tuple element by numeric index
- **`KeyStep`** - Navigate to a map element by string key

Paths are primarily used for error reporting (providing clear indication of where validation failed) and programmatic navigation through complex structures. They enable precise identification of data locations like `root.users[2].address.city`.

**Use Cases**:
- Error messages showing exact location of validation failures
- Programmatic traversal of nested configurations
- Building tools that need to reference specific parts of a structure

For detailed path navigation documentation, see: **[User Guide: Path Navigation](../user-guide/advanced/path-navigation.md)**

---

::: pyvider.cty.path
    options:
      show_source: true
      show_root_heading: true
      members_order: source
      show_if_no_docstring: false
      filters:
        - "!^_"
        - "^__init__$"
>>> EOF >>>

### FILE 8: api/types/capsule.md | checksum=5c587bede1ec... | modified=2025-11-15T19:17:59 | op=+ | size=1175 | tokens=257 | type=markdown ###
<<< BOF <<<
# Capsule Types

Capsule types allow you to encapsulate opaque Python objects within the cty type system. They are useful for wrapping foreign data types that cannot be represented by the standard cty types, such as file handles, database connections, or other external resources.

The capsule types are:
- **`CtyCapsule`** - Base capsule type for wrapping arbitrary Python objects with type checking
- **`CtyCapsuleWithOps`** - Extended capsule type that supports custom operations on encapsulated data
- **`BytesCapsule`** - Pre-defined capsule type for wrapping raw bytes data

Capsule types provide type safety by validating that encapsulated objects match the expected Python type. They preserve the opaque nature of the data while allowing it to participate in the cty type system for validation, serialization, and other operations.

See also: **[User Guide: Capsule Types](../../user-guide/type-reference/capsule.md)** for detailed usage examples.

---

::: pyvider.cty.types.capsule
    options:
      show_source: true
      show_root_heading: true
      members_order: source
      show_if_no_docstring: false
      filters:
        - "!^_"
        - "^__init__$"
>>> EOF >>>

### FILE 9: api/types/collections.md | checksum=ac28c9e5d340... | modified=2025-11-15T19:17:59 | op=+ | size=1092 | tokens=223 | type=markdown ###
<<< BOF <<<
# Collection Types

Collection types represent containers that hold multiple elements of a homogeneous type. All elements in a collection must conform to the same `element_type` specification.

The three collection types are:
- **`CtyList`** - Ordered collection that preserves element order and allows duplicates
- **`CtySet`** - Unordered collection of unique elements (automatically removes duplicates)
- **`CtyMap`** - Key-value mapping where keys are always strings and values are of a specified type

Collections recursively validate all their elements during validation, ensuring type safety throughout nested structures. Collections are also iterable, allowing you to use standard Python iteration patterns (`for element in list_value`).

See also: **[User Guide: Collection Types](../../user-guide/type-reference/collections.md)** for detailed usage examples.

---

::: pyvider.cty.types.collections
    options:
      show_source: true
      show_root_heading: true
      members_order: source
      show_if_no_docstring: false
      filters:
        - "!^_"
        - "^__init__$"
>>> EOF >>>

### FILE 10: api/types/index.md | checksum=94895e2accb6... | modified=2025-11-15T19:17:59 | op=+ | size=1041 | tokens=248 | type=markdown ###
<<< BOF <<<
# CTY Types

The `pyvider.cty.types` module provides the core type system for defining and validating data structures. Types act as schemas that describe the shape, structure, and constraints of your data.

All types inherit from the `CtyType` base class and provide a `validate()` method that converts raw Python data into immutable, type-safe `CtyValue` instances. The type system includes primitives (String, Number, Bool), collections (List, Map, Set), structural types (Object, Tuple), and special types (Dynamic, Capsule).

For detailed information about each type category, see:
- **[Primitive Types](primitives.md)** - String, Number, Bool
- **[Collection Types](collections.md)** - List, Map, Set
- **[Structural Types](structural.md)** - Object, Tuple, Dynamic
- **[Capsule Types](capsule.md)** - Opaque data containers

---

::: pyvider.cty.types
    options:
      show_source: true
      show_root_heading: true
      members_order: source
      show_if_no_docstring: false
      filters:
        - "!^_"
        - "^__init__$"
>>> EOF >>>

### FILE 11: api/types/primitives.md | checksum=69811cd48781... | modified=2025-11-15T19:17:59 | op=+ | size=1113 | tokens=247 | type=markdown ###
<<< BOF <<<
# Primitive Types

Primitive types are the fundamental building blocks of the pyvider.cty type system. They represent single, atomic values that cannot be decomposed into simpler types.

The three primitive types are:
- **`CtyString`** - Represents text values with Unicode support (NFC normalization)
- **`CtyNumber`** - Represents numeric values (integers and decimals) with arbitrary precision using Python's `Decimal` type
- **`CtyBool`** - Represents boolean values (`True` or `False`)

Primitive types perform strict validation - they do not perform automatic type coercion. For example, `CtyNumber().validate("123")` will raise a validation error because the input is a string, not a number. Use the conversion functions if you need flexible type transformation.

See also: **[User Guide: Primitive Types](../../user-guide/type-reference/primitives.md)** for detailed usage examples.

---

::: pyvider.cty.types.primitives
    options:
      show_source: true
      show_root_heading: true
      members_order: source
      show_if_no_docstring: false
      filters:
        - "!^_"
        - "^__init__$"
>>> EOF >>>

### FILE 12: api/types/structural.md | checksum=0ea874fc9b5f... | modified=2025-11-15T19:17:59 | op=+ | size=1329 | tokens=269 | type=markdown ###
<<< BOF <<<
# Structural Types

Structural types define complex data structures with heterogeneous elements, where different positions or attributes can have different types. Unlike collections, structural types allow mixing different types within the same structure.

The structural types are:
- **`CtyObject`** - A structure with named attributes, each having its own type (similar to a typed dictionary). Supports optional attributes that can be omitted from data.
- **`CtyTuple`** - A fixed-length sequence where each position has a specific type (similar to a typed tuple). The number of elements and their types are defined at schema creation.
- **`CtyDynamic`** - A special type that can represent any value, with the actual type determined at runtime. Useful for scenarios where the type structure isn't known until runtime.

Structural types are ideal for modeling complex domain objects, API responses, and configuration schemas where different fields have different meanings and types.

See also: **[User Guide: Structural Types](../../user-guide/type-reference/structural.md)** for detailed usage examples.

---

::: pyvider.cty.types.structural
    options:
      show_source: true
      show_root_heading: true
      members_order: source
      show_if_no_docstring: false
      filters:
        - "!^_"
        - "^__init__$"
>>> EOF >>>

### FILE 13: api/validation.md | checksum=fb09ecb4e9f7... | modified=2025-11-15T19:17:59 | op=+ | size=1752 | tokens=373 | type=markdown ###
<<< BOF <<<
# CTY Validation

The `pyvider.cty.validation` module provides utilities for preventing infinite recursion during validation of deeply nested or circular data structures.

Key components:
- **`RecursionContext`** - Tracks visited objects during validation to detect cycles
- **`RecursionDetector`** - Manages recursion detection state
- **`with_recursion_detection`** - Decorator that adds recursion detection to validation methods
- **`get_recursion_context()`** - Returns the current recursion context
- **`clear_recursion_context()`** - Clears the recursion detection state
- **`validate_config(schema, config)`** - Convenience function for validating configurations against schemas (raises `CtyValidationError` on failure)

The recursion detection system is used internally by all types during the validation process. You typically won't need to interact with it directly unless you're implementing custom types that need to participate in cycle detection.

**Usage Example:**

```python
from pyvider.cty import CtyObject, CtyString
from pyvider.cty.validation import validate_config

schema = CtyObject(attribute_types={"name": CtyString()})
config = {"name": "Alice"}

# This validates and raises on error, but doesn't return the CtyValue
validate_config(schema, config)

# For most use cases, prefer calling validate() directly on the type:
validated_value = schema.validate(config)  # Returns CtyValue
```

For comprehensive validation documentation, see: **[User Guide: Validation](../user-guide/core-concepts/validation.md)**

---

::: pyvider.cty.validation
    options:
      show_source: true
      show_root_heading: true
      members_order: source
      show_if_no_docstring: false
      filters:
        - "!^_"
        - "^__init__$"
>>> EOF >>>

### FILE 14: api/values.md | checksum=5a7266972cb5... | modified=2025-11-15T19:17:59 | op=+ | size=1434 | tokens=325 | type=markdown ###
<<< BOF <<<
# CTY Values

The `pyvider.cty.values` module defines the `CtyValue` class, which represents immutable, type-safe data instances in the cty system.

Key concepts:
- **Immutability** - Once created, `CtyValue` instances cannot be modified. All operations return new values.
- **Type safety** - Every value has an associated `CtyType` that governs its structure and operations
- **Special values** - Support for null values (`CtyValue.null(type)`) and unknown values (`CtyValue.unknown(type)`)
- **Marks** - Ability to attach metadata to values without modifying the value itself
- **Raw value access** - Use the `.raw_value` property to access the underlying Python value

**Creating Values**: You should always create values through type validation (`my_type.validate(data)`) rather than constructing `CtyValue` directly. The validation process ensures type safety and proper initialization.

**Accessing Data**: Values support Python's standard access patterns - use `value['attr']` for object attributes, `value[index]` for list/tuple elements, and iteration (`for item in list_value`) for collections.

For detailed value documentation, see: **[User Guide: Working with Values](../user-guide/core-concepts/values.md)**

---

::: pyvider.cty.values
    options:
      show_source: true
      show_root_heading: true
      members_order: source
      show_if_no_docstring: false
      filters:
        - "!^_"
        - "^__init__$"
>>> EOF >>>

### FILE 15: archive/ARCHITECTURAL_ANALYSIS.md | checksum=1f2560fd3ccc... | modified=2025-11-15T19:04:27 | op=+ | size=34450 | tokens=8683 | type=markdown ###
<<< BOF <<<
# pyvider-cty: Comprehensive Architectural Analysis & Review

**Analysis Date**: November 12, 2025
**Version Analyzed**: 0.0.1026 (Alpha)
**Python Requirement**: 3.11+

---

## Executive Summary

**pyvider-cty** is a pure-Python implementation of the go-cty type system providing strong type validation, serialization, and Terraform interoperability. This analysis evaluates architectural soundness, enterprise readiness, release preparedness, and developer experience.

### Key Findings

| Dimension | Rating | Status |
|-----------|--------|--------|
| **Architecture** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Excellent - Clean separation, solid patterns |
| **Code Quality** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Excellent - 100% type safety, strict linting |
| **Test Coverage** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Excellent - 94% coverage, comprehensive suite |
| **Documentation** | ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ | Very Good - Complete but missing module docstrings |
| **Release Readiness** | ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ | Good - Alpha appropriate, needs GA planning |
| **Enterprise Readiness** | ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ | Good - Security clean, performance noted |
| **Developer Experience** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Excellent - Modern tooling, clear APIs |

### Overall Assessment

**RECOMMENDATION: STRONG GO** for continued development toward production release.

The project demonstrates **exceptional engineering discipline** with professional-grade architecture, tooling, and testing. The alpha designation is appropriate given API evolution, but core implementation is production-quality. Primary focus areas for GA: performance optimization, module documentation completion, and dependency portability.

---

## 1. Architectural Analysis

### 1.1 Project Structure

```
pyvider-cty/
‚îú‚îÄ‚îÄ src/pyvider/cty/              # 56 Python files, ~7,367 LOC
‚îÇ   ‚îú‚îÄ‚îÄ types/                    # Type system (11 files)
‚îÇ   ‚îú‚îÄ‚îÄ values/                   # Value objects (3 files)
‚îÇ   ‚îú‚îÄ‚îÄ functions/                # Standard library (10 files, 72 functions)
‚îÇ   ‚îú‚îÄ‚îÄ conversion/               # Type conversion (7 files)
‚îÇ   ‚îú‚îÄ‚îÄ exceptions/               # Error hierarchy (4 files, 21 types)
‚îÇ   ‚îú‚îÄ‚îÄ path/                     # Path navigation (2 files)
‚îÇ   ‚îú‚îÄ‚îÄ validation/               # Validation infrastructure (2 files)
‚îÇ   ‚îú‚îÄ‚îÄ context/                  # Context management (2 files)
‚îÇ   ‚îú‚îÄ‚îÄ config/                   # Configuration (3 files)
‚îÇ   ‚îú‚îÄ‚îÄ codec.py                  # JSON/MessagePack serialization
‚îÇ   ‚îú‚îÄ‚îÄ parser.py                 # Terraform type parsing
‚îÇ   ‚îî‚îÄ‚îÄ marks.py                  # Mark system
‚îú‚îÄ‚îÄ tests/                        # 154 test files across 26 categories
‚îú‚îÄ‚îÄ docs/                         # 46 Markdown files
‚îú‚îÄ‚îÄ examples/                     # 16 example files (3 categories)
‚îú‚îÄ‚îÄ compatibility/                # Cross-language Go/Python tests
‚îî‚îÄ‚îÄ .github/workflows/            # 3 CI/CD workflows
```

**Pros:**
- ‚úÖ **Clean layered architecture** with clear separation of concerns
- ‚úÖ **Logical package organization** following domain boundaries
- ‚úÖ **Consistent file structure** throughout codebase
- ‚úÖ **No circular dependencies** in critical paths
- ‚úÖ **Centralized configuration** (config/defaults.py) - zero hardcoded values

**Cons:**
- ‚ö†Ô∏è **Dependency on provide-foundation** may limit portability
- ‚ö†Ô∏è Deep nesting in some modules could be flattened

### 1.2 Type System Architecture

**Hierarchy:**
```
CtyType[T] (Generic ABC + Protocol)
‚îú‚îÄ‚îÄ Primitives (order 0-2)
‚îÇ   ‚îú‚îÄ‚îÄ CtyBool
‚îÇ   ‚îú‚îÄ‚îÄ CtyString (NFC normalization)
‚îÇ   ‚îî‚îÄ‚îÄ CtyNumber (Decimal precision)
‚îú‚îÄ‚îÄ Collections (order 3-5)
‚îÇ   ‚îú‚îÄ‚îÄ CtyMap
‚îÇ   ‚îú‚îÄ‚îÄ CtySet
‚îÇ   ‚îî‚îÄ‚îÄ CtyList
‚îú‚îÄ‚îÄ Structural (order 6-9)
‚îÇ   ‚îú‚îÄ‚îÄ CtyTuple
‚îÇ   ‚îú‚îÄ‚îÄ CtyObject
‚îÇ   ‚îú‚îÄ‚îÄ CtyCapsule
‚îÇ   ‚îî‚îÄ‚îÄ CtyDynamic
‚îî‚îÄ‚îÄ CtyCapsuleWithOps (with custom operations)
```

**Design Patterns:**
- ‚úÖ **Protocol + ABC Pattern**: Flexible typing with `CtyTypeProtocol[T]` + `CtyType[T]`
- ‚úÖ **Generic Type System**: Full covariance support with `TypeVar("T_co", covariant=True)`
- ‚úÖ **Type Ordering**: `_type_order` ClassVar for canonical sorting
- ‚úÖ **Wire Format Abstraction**: `._to_wire_json()` for serialization

**Pros:**
- ‚úÖ **Type safety throughout** - 100% mypy strict compliance
- ‚úÖ **Extensible design** - Easy to add new types
- ‚úÖ **Go-cty compatible** - Wire format matches upstream
- ‚úÖ **Modern Python 3.11+ features** (union operator, native types)

**Cons:**
- ‚ö†Ô∏è **Generic constraints** - `.raw_value` returns `object | None` (documented limitation)
- ‚ö†Ô∏è Some API methods return `CtyValue[Any]` due to type system constraints

### 1.3 Value System Architecture

```python
@define(frozen=True, slots=True)
class CtyValue(Generic[T]):
    vtype: CtyType[T]              # Type information
    value: object | None           # Actual value
    is_unknown: bool = False       # Unknown/computed value
    is_null: bool = False          # Null value
    marks: frozenset[Any]          # Metadata marks
```

**Key Features:**
- ‚úÖ **Immutable by default** using attrs `frozen=True`
- ‚úÖ **Efficient storage** with `slots=True`
- ‚úÖ **Rich operations** - 30+ dunder methods for Pythonic API
- ‚úÖ **Mark system** for metadata attachment without mutation
- ‚úÖ **Unknown value refinements** with bounds/constraints
- ‚úÖ **Canonical sorting** for deterministic set/map ordering

**Pros:**
- ‚úÖ **Thread-safe** - Immutability ensures safety
- ‚úÖ **Memory efficient** - slots reduce overhead
- ‚úÖ **Pythonic** - Supports `[]`, `len()`, `in`, iteration naturally
- ‚úÖ **Error boundaries** integrated for failure handling

**Cons:**
- ‚ö†Ô∏è Complexity in `_canonical_sort_key()` method (acceptable given purpose)

### 1.4 Conversion & Serialization

**Conversion System:**
1. **Explicit Conversion** (`explicit.py`): Type-to-type conversion with `convert()`, `unify()`
2. **Type Inference** (`raw_to_cty.py`): Auto-detection from Python values
3. **Native Adapter** (`adapter.py`): CtyValue ‚Üí Python native unwrapping
4. **Type Encoder** (`type_encoder.py`): Wire format encoding

**Codec System:**
- **MessagePack**: Binary serialization with extension types (0, 12)
- **JSON**: Type-preserving text serialization
- **Terraform-compatible**: Wire format matches go-cty

**Pros:**
- ‚úÖ **Cross-language compatibility** verified via Go fixture tests
- ‚úÖ **Performance caching** - Inference cache using ContextVars
- ‚úÖ **Round-trip fidelity** - Extensive codec tests verify preservation
- ‚úÖ **Precision preservation** - Numbers as UTF-8 bytes in MessagePack

**Cons:**
- ‚ö†Ô∏è **Go runtime required** for compatibility test fixtures (optional)

### 1.5 Function Library

**72 Functions across 8 categories:**

| Category | Count | Examples |
|----------|-------|----------|
| Collection | 23 | `distinct`, `flatten`, `sort`, `concat`, `merge` |
| String | 17 | `upper`, `trim`, `split`, `regex`, `indent` |
| Numeric | 13 | `abs_fn`, `ceil_fn`, `add`, `multiply`, `pow_fn` |
| Comparison | 8 | `equal`, `greater_than`, `min_fn`, `max_fn` |
| Conversion | 3 | `to_bool`, `to_string`, `to_number` |
| DateTime | 2 | `formatdate`, `timeadd` |
| Encoding | 3 | `jsonencode`, `jsondecode`, `csvdecode` |
| Bytes | 2 | `byteslen`, `bytesslice` |

**Pros:**
- ‚úÖ **Terraform stdlib compatibility** - Familiar API
- ‚úÖ **Null/unknown propagation** - Correct semantics
- ‚úÖ **Rich error messages** with context
- ‚úÖ **Type validation** at entry points

**Cons:**
- ‚ö†Ô∏è Coverage not yet complete for all go-cty functions (acceptable for alpha)

---

## 2. Code Quality Analysis

### 2.1 Type Safety

**Metrics:**
- **Mypy Errors**: 0 (100% type safe)
- **Mypy Mode**: Strict
- **Type Annotation Coverage**: 100%
- **Python Version**: 3.11+ (modern syntax)

**Strengths:**
- ‚úÖ Complete type annotations on all public APIs
- ‚úÖ Modern Python 3.11+ syntax (`dict` not `Dict`, `|` not `Union`)
- ‚úÖ Proper use of `from __future__ import annotations`
- ‚úÖ Generic types with covariance correctly implemented
- ‚úÖ `TYPE_CHECKING` guards prevent circular imports

**Evidence:**
```python
# Example: src/pyvider/cty/types/base.py
@define(slots=True)
class CtyType(CtyTypeProtocol[T], Generic[T], ABC):
    """Generic abstract base class for all Cty types."""

    @abstractmethod
    def validate(self, value: object) -> CtyValue[T]:
        pass
```

### 2.2 Code Style & Consistency

**Tooling:**
- **Ruff**: Format + lint (line length: 111)
- **Rules**: E, F, W, I, UP, ANN, B, C90, SIM, PTH, RUF
- **Ignores**: ANN401 (Any), B008 (function calls in defaults), E501 (line length)

**Metrics:**
- **Lines of Code**: 7,367 (source only)
- **Average File Length**: ~132 lines (manageable)
- **Cyclomatic Complexity**: Some `# noqa: C901` in validation (acceptable)

**Strengths:**
- ‚úÖ **Consistent formatting** throughout codebase
- ‚úÖ **Clean imports** - Organized and sorted
- ‚úÖ **No hardcoded values** - All in config/defaults.py
- ‚úÖ **Descriptive naming** - Clear variable/function names
- ‚úÖ **Visual markers** - Emoji comments (üåäü™¢üîö) for navigation

**Weaknesses:**
- ‚ö†Ô∏è **Missing module docstrings** - Many files have `"""TODO: Add module docstring."""`
- ‚ö†Ô∏è Some complex functions marked with complexity warnings (inherent to domain)

### 2.3 Error Handling

**Exception Hierarchy:**
```
CtyError (base)
‚îú‚îÄ‚îÄ CtyFunctionError (base for function errors)
‚îú‚îÄ‚îÄ Validation Errors (9 types)
‚îÇ   ‚îú‚îÄ‚îÄ CtyValidationError
‚îÇ   ‚îú‚îÄ‚îÄ CtyTypeError
‚îÇ   ‚îú‚îÄ‚îÄ CtyAttributeError
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ Conversion Errors (3 types)
‚îÇ   ‚îú‚îÄ‚îÄ CtyConversionError
‚îÇ   ‚îú‚îÄ‚îÄ CtyTypeConversionError
‚îÇ   ‚îî‚îÄ‚îÄ CtyUnificationError
‚îî‚îÄ‚îÄ Encoding Errors (9 types)
    ‚îú‚îÄ‚îÄ CtyEncodingError
    ‚îú‚îÄ‚îÄ CtyMessagePackError
    ‚îî‚îÄ‚îÄ ...
```

**Strengths:**
- ‚úÖ **Rich error context** - Path tracking in validation errors
- ‚úÖ **Clear error messages** - Template-based from defaults.py
- ‚úÖ **Error boundary integration** - Uses provide.foundation
- ‚úÖ **Proper exception hierarchy** - Easy to catch specific errors

**Evidence:**
```python
# Centralized error messages
ERR_CANNOT_GET_RAW_VALUE_UNKNOWN = (
    "Cannot access raw_value on unknown CtyValue. "
    "Check is_unknown before accessing raw_value."
)
```

### 2.4 Performance Considerations

**Optimizations:**
- ‚úÖ **Type inference caching** - ContextVars-based LRU cache
- ‚úÖ **Fast paths** - Pre-validated values skip re-validation
- ‚úÖ **Slots usage** - Memory-efficient classes with `__slots__`
- ‚úÖ **Recursion detection** - Configurable limits (500 depth, 30s timeout)

**Known Limitations (from README):**
- ‚ö†Ô∏è "Not yet optimized for very large or deeply nested data structures"
- ‚ö†Ô∏è Performance reasonable for typical use cases
- ‚ö†Ô∏è Performance benchmarks exist but optimization ongoing

**Recommendation**: Performance is appropriate for alpha; prioritize profiling for GA.

---

## 3. Test Coverage & Quality

### 3.1 Test Metrics

| Metric | Value | Assessment |
|--------|-------|------------|
| **Test Files** | 154 | Excellent |
| **Test Coverage** | 94% | Excellent |
| **Coverage Target** | 75% minimum | Exceeded |
| **Test Categories** | 26 | Comprehensive |
| **Property-Based Tests** | 15 files | Advanced |
| **Compatibility Tests** | Go/Python | Cross-language |

### 3.2 Test Organization

```
tests/
‚îú‚îÄ‚îÄ codec/              # Serialization (8 files)
‚îú‚îÄ‚îÄ collections/        # Collection types
‚îú‚îÄ‚îÄ compatibility/      # Go/Python interop
‚îú‚îÄ‚îÄ context/           # Context management
‚îú‚îÄ‚îÄ conversion/        # Type conversion (14 files)
‚îú‚îÄ‚îÄ coverage/          # Edge case hardening
‚îú‚îÄ‚îÄ diagnostics/       # Error messages
‚îú‚îÄ‚îÄ dynamic/           # Dynamic type
‚îú‚îÄ‚îÄ exceptions/        # Exception behavior (3 files)
‚îú‚îÄ‚îÄ fixtures/          # Test data (go-cty generated)
‚îú‚îÄ‚îÄ functions/         # Function tests (21 files)
‚îú‚îÄ‚îÄ list/map/set/      # Collection type tests
‚îú‚îÄ‚îÄ object/tuple/      # Structural type tests
‚îú‚îÄ‚îÄ parser/            # Parser tests (2 files)
‚îú‚îÄ‚îÄ path/              # Path navigation (2 files)
‚îú‚îÄ‚îÄ performance/       # Benchmarks (3 files)
‚îú‚îÄ‚îÄ property_based/    # Hypothesis tests (15 files)
‚îú‚îÄ‚îÄ tdd/               # TDD contracts (2 files)
‚îú‚îÄ‚îÄ types/             # Type-specific tests
‚îú‚îÄ‚îÄ validation/        # Validation tests
‚îî‚îÄ‚îÄ values/            # Value tests
```

**Strengths:**
- ‚úÖ **Comprehensive coverage** - All major subsystems tested
- ‚úÖ **Property-based testing** - Hypothesis for fuzzing (15 files)
- ‚úÖ **Cross-language compatibility** - Go fixture generation
- ‚úÖ **Performance benchmarks** - Dedicated performance tests
- ‚úÖ **Edge case coverage** - Dedicated coverage hardening tests
- ‚úÖ **TDD approach** - Contract tests document expectations

### 3.3 Test Infrastructure

**Framework**: pytest with custom fixtures

**Key Fixtures:**
- `go_fixtures`: Auto-generates Go fixtures for compatibility
- `clear_recursion_context`: Per-test isolation
- `clear_inference_cache`: Cache reset between tests
- `configure_foundation_logger_for_tests`: Test-safe logging

**Test Markers:**
- `@pytest.mark.benchmark`: Performance tests (requires `--run-benchmarks`)
- `@pytest.mark.compat`: Go/Python compatibility (requires `--run-compat`)
- `@pytest.mark.slow`: Long-running tests

**Strengths:**
- ‚úÖ **Clean test isolation** - Proper setup/teardown
- ‚úÖ **Configurable execution** - Optional markers for expensive tests
- ‚úÖ **Automated fixture generation** - Go fixtures auto-created
- ‚úÖ **Parallel execution** - Coverage configured for parallelism

---

## 4. Documentation Assessment

### 4.1 Documentation Structure

**46 Markdown files organized as:**

```
docs/
‚îú‚îÄ‚îÄ index.md                       # Landing page
‚îú‚îÄ‚îÄ getting-started/ (5 files)     # Quick start, installation, first steps
‚îú‚îÄ‚îÄ user-guide/                    # Complete feature guide
‚îÇ   ‚îú‚îÄ‚îÄ core-concepts/ (4 files)  # Types, values, validation, conversion
‚îÇ   ‚îú‚îÄ‚îÄ type-reference/ (5 files) # Primitives, collections, structural
‚îÇ   ‚îî‚îÄ‚îÄ advanced/ (5 files)       # Marks, functions, serialization
‚îú‚îÄ‚îÄ how-to/ (5 files)              # Task-oriented guides
‚îú‚îÄ‚îÄ api/ (9 files)                 # API reference (auto-generated)
‚îî‚îÄ‚îÄ reference/ (4 files)           # Troubleshooting, glossary, go-cty comparison
```

### 4.2 Documentation Quality

**Strengths:**
- ‚úÖ **Comprehensive coverage** - All features documented
- ‚úÖ **Multiple perspectives** - Tutorial, guide, reference, how-to
- ‚úÖ **Code examples** throughout - Every guide includes examples
- ‚úÖ **API auto-generation** - mkdocstrings for API docs
- ‚úÖ **Migration guide** - From go-cty to pyvider-cty
- ‚úÖ **Troubleshooting section** - Common issues addressed
- ‚úÖ **Cross-references** - Good linking between sections

**Weaknesses:**
- ‚ö†Ô∏è **Missing module docstrings** - Implementation files have `"""TODO: Add module docstring."""`
- ‚ö†Ô∏è Module docstrings would improve auto-generated API docs

**Documentation System:**
- **Tool**: MkDocs Material theme
- **Features**: Search, dark mode, copy buttons, Mermaid diagrams
- **Style**: Google docstring format
- **Dev Server**: Port 8004

### 4.3 Example Code

**16 example files across 3 categories:**

```
examples/
‚îú‚îÄ‚îÄ getting-started/
‚îÇ   ‚îî‚îÄ‚îÄ quick-start.py
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îú‚îÄ‚îÄ primitives.py
‚îÇ   ‚îú‚îÄ‚îÄ collections.py
‚îÇ   ‚îú‚îÄ‚îÄ structural.py
‚îÇ   ‚îú‚îÄ‚îÄ dynamic.py
‚îÇ   ‚îî‚îÄ‚îÄ capsule.py
‚îî‚îÄ‚îÄ advanced/
    ‚îú‚îÄ‚îÄ marks.py
    ‚îú‚îÄ‚îÄ functions.py
    ‚îú‚îÄ‚îÄ serialization.py
    ‚îú‚îÄ‚îÄ path-navigation.py
    ‚îî‚îÄ‚îÄ terraform-interop.py
```

**Strengths:**
- ‚úÖ **Runnable examples** - All examples can be executed
- ‚úÖ **Comprehensive coverage** - All major features demonstrated
- ‚úÖ **Batch execution** - `run_all_examples.py` for testing
- ‚úÖ **Common utilities** - `example_utils.py` for setup

---

## 5. Release Readiness

### 5.1 Version Management

| Aspect | Status | Details |
|--------|--------|---------|
| **Current Version** | 0.0.1026 | Alpha |
| **Version Source** | `VERSION` file | Single source of truth |
| **Development Status** | Alpha | pyproject.toml classifier |
| **Semantic Versioning** | Yes | Following semver |
| **Changelog** | Maintained | CHANGELOG.md (Keep a Changelog format) |

**Strengths:**
- ‚úÖ **Clear alpha designation** - Manages expectations
- ‚úÖ **Changelog maintained** - All changes documented
- ‚úÖ **Single version source** - VERSION file prevents drift

**Readiness Assessment:**
- ‚úÖ **Alpha appropriate** - API still evolving, documented limitations
- ‚ö†Ô∏è **Beta criteria needed** - Define requirements for beta promotion
- ‚ö†Ô∏è **GA roadmap needed** - Plan for 1.0.0 release

### 5.2 Packaging & Distribution

**Build System:**
- **Tool**: setuptools with `src/` layout
- **Package Manager**: uv (modern, fast)
- **Build Command**: `uv build`
- **Output**: Wheel in `dist/`

**Dependencies:**
```toml
dependencies = [
    "attrs>=25.1.0",
    "msgpack>=1.1.0",
    "provide-foundation",
]
```

**Strengths:**
- ‚úÖ **Modern packaging** - src/ layout best practice
- ‚úÖ **Locked dependencies** - uv.lock for reproducibility
- ‚úÖ **Clean metadata** - pyproject.toml well-organized
- ‚úÖ **Platform independent** - Pure Python, cross-platform

**Concerns:**
- ‚ö†Ô∏è **provide-foundation dependency** - Path dependency: `../provide-foundation`
  - May be internal/private package
  - Could limit external adoption
  - **Recommendation**: Consider vendoring or making public

### 5.3 CI/CD Pipeline

**GitHub Actions Workflows:**

1. **ci.yml** - Tests & Quality
   - **Quality Job**: Ruff, mypy, bandit (single runner)
   - **Test Job**: Matrix across OS (Ubuntu, macOS, Windows) and Python (3.11, 3.12, 3.13)
   - **Build Job**: Package build + artifact upload
   - **Security Job**: Optional security scan
   - **Coverage**: Upload to Codecov (94%)

2. **release.yml** - Release Automation
   - **Trigger**: Version tag push or manual
   - **Steps**: Download artifacts ‚Üí TestPyPI ‚Üí PyPI ‚Üí GitHub Release
   - **Publishing**: Trusted publishing (no tokens)

3. **mutation-testing.yml** - Code Quality
   - Tests the test suite quality

**Strengths:**
- ‚úÖ **Comprehensive CI** - Quality, tests, security, build
- ‚úÖ **Matrix testing** - Cross-platform, multi-Python
- ‚úÖ **Automated release** - Tag-triggered deployment
- ‚úÖ **Trusted publishing** - Secure PyPI deployment
- ‚úÖ **Mutation testing** - Advanced quality verification

**Local Validation:**
- ‚úÖ **validate-pipeline.sh** - Complete local validation
- ‚úÖ **Pre-commit hooks** - 13 hooks including ruff, mypy, bandit

---

## 6. Enterprise Readiness

### 6.1 Security

**Security Measures:**
- ‚úÖ **Bandit scanning** - Clean (Level -ll)
- ‚úÖ **No hardcoded secrets** - .secrets.example template
- ‚úÖ **Input validation** - All boundaries validated
- ‚úÖ **No SQL injection vectors** - No database access
- ‚úÖ **Dependency scanning** - Via CI/CD
- ‚úÖ **Pre-commit hooks** - Debug statement detection

**Security Audit Results:**
- **Bandit Scan**: PASS (0 issues)
- **Known Vulnerabilities**: None identified
- **Secret Exposure**: None

**Recommendation**: ‚úÖ **SECURITY APPROVED** for enterprise deployment.

### 6.2 Performance & Scalability

**Current State:**
- ‚úÖ **Type inference caching** implemented
- ‚úÖ **Fast paths** for pre-validated values
- ‚úÖ **Recursion limits** configurable (500 depth, 30s timeout)
- ‚úÖ **Memory efficiency** - slots usage
- ‚ö†Ô∏è **Known limitation**: "Not yet optimized for very large or deeply nested data structures"

**Performance Testing:**
- ‚úÖ Dedicated `tests/performance/` directory (3 files)
- ‚úÖ Benchmark marker (`@pytest.mark.benchmark`)
- ‚ö†Ô∏è No published benchmark results

**Scalability Assessment:**
| Use Case | Assessment | Notes |
|----------|------------|-------|
| **Small datasets (<1K items)** | ‚úÖ Excellent | No concerns |
| **Medium datasets (1K-100K)** | ‚úÖ Good | Reasonable performance |
| **Large datasets (>100K)** | ‚ö†Ô∏è Unverified | Profiling recommended |
| **Deep nesting (>50 levels)** | ‚ö†Ô∏è Concern noted | Recursion limits help |

**Recommendations:**
1. **Profile representative workloads** before GA
2. **Publish benchmark results** for transparency
3. **Document performance characteristics** in docs
4. **Consider optimization** for large-scale use cases if needed

### 6.3 Operational Readiness

**Logging:**
- ‚úÖ Integrated with `provide.foundation.logger`
- ‚úÖ Test-safe logging configuration
- ‚úÖ Structured logging available

**Monitoring:**
- ‚ö†Ô∏è No built-in metrics/telemetry (acceptable for library)
- ‚úÖ Error boundaries for failure tracking
- ‚úÖ Rich exception context for debugging

**Deployment:**
- ‚úÖ **Pure Python** - Simple deployment
- ‚úÖ **PyPI distribution** - Standard installation
- ‚úÖ **Version pinning** - Supports reproducible builds
- ‚úÖ **Python 3.11-3.14 support** - Future-compatible

**Maintenance:**
- ‚úÖ **Active development** - Recent commits
- ‚úÖ **Clear contribution guide** - CONTRIBUTING.md
- ‚úÖ **Issue tracking** - GitHub issues
- ‚úÖ **Changelog maintained** - Release notes

---

## 7. Developer Experience

### 7.1 API Design

**Design Principles:**
- ‚úÖ **Pythonic** - Follows Python conventions (`__getitem__`, `__len__`, etc.)
- ‚úÖ **Type-safe** - Full type hints for IDE support
- ‚úÖ **Immutable** - Safe by default
- ‚úÖ **Composable** - Types compose naturally
- ‚úÖ **Explicit** - Clear error messages, no magic

**API Examples:**

```python
# Clean, intuitive API
user_type = CtyObject(
    attribute_types={
        "name": CtyString(),
        "age": CtyNumber(),
    },
    optional_attributes={"age"},
)

user_val = user_type.validate({"name": "Alice"})
print(user_val["name"].raw_value)  # "Alice"
```

**Strengths:**
- ‚úÖ **Discoverable** - Clear naming, IDE autocomplete
- ‚úÖ **Consistent** - Similar patterns across types
- ‚úÖ **Forgiving** - Good error messages guide users
- ‚úÖ **Familiar** - Similar to go-cty for migration

### 7.2 Development Environment

**Setup:**
```bash
git clone https://github.com/provide-io/pyvider-cty.git
cd pyvider-cty
uv sync  # One command setup
```

**Strengths:**
- ‚úÖ **One-command setup** - `uv sync` does everything
- ‚úÖ **Fast dependency resolution** - uv is blazing fast
- ‚úÖ **Automatic venv** - Creates .venv/ automatically
- ‚úÖ **Platform-aware** - Handles OS differences
- ‚úÖ **Reproducible** - uv.lock ensures consistency

**Development Commands:**
```bash
uv run pytest tests/                    # Run tests
uv run ruff format src/ tests/          # Format code
uv run ruff check src/ tests/ --fix     # Lint and fix
uv run mypy src/                        # Type check
./validate-pipeline.sh                  # Full validation
```

**Strengths:**
- ‚úÖ **Simple commands** - Consistent `uv run` prefix
- ‚úÖ **Fast feedback** - Modern tools are fast
- ‚úÖ **Complete validation** - Single script for all checks

### 7.3 Onboarding Experience

**Documentation Path:**
1. **README.md** - Quick overview and example
2. **docs/getting-started/** - Installation and first steps
3. **docs/user-guide/** - Complete feature guide
4. **examples/** - Runnable code examples
5. **docs/api/** - Detailed API reference

**Time to First Success:**
- ‚úÖ **< 5 minutes** - Install and run first example
- ‚úÖ **< 30 minutes** - Understand core concepts
- ‚úÖ **< 2 hours** - Build first real use case

**Strengths:**
- ‚úÖ **Clear path** - Documentation guides progression
- ‚úÖ **Working examples** - Copy-paste and learn
- ‚úÖ **Migration guide** - Easy transition from go-cty
- ‚úÖ **Troubleshooting** - Common issues documented

### 7.4 Tooling Ecosystem

**Integrated Tools:**
- ‚úÖ **Ruff** - Format + lint (modern, fast)
- ‚úÖ **Mypy** - Type checking (strict mode)
- ‚úÖ **Pytest** - Testing framework
- ‚úÖ **Pre-commit** - Git hooks
- ‚úÖ **Bandit** - Security scanning
- ‚úÖ **Coverage** - Test coverage tracking
- ‚úÖ **MkDocs** - Documentation generation

**IDE Support:**
- ‚úÖ **VS Code** - Full type hints support
- ‚úÖ **PyCharm** - Professional IDE support
- ‚úÖ **Type stubs** - Complete annotations

---

## 8. Risk Assessment

### 8.1 Technical Risks

| Risk | Severity | Likelihood | Mitigation |
|------|----------|------------|------------|
| **Performance at scale** | Medium | Medium | Profile and optimize before GA |
| **provide-foundation dependency** | Medium | Low | Consider vendoring or public release |
| **API changes (alpha)** | Low | High | Expected in alpha, document changes |
| **Cross-language compatibility** | Low | Low | Extensive compatibility tests |
| **Type system limitations** | Low | Medium | Documented, acceptable tradeoffs |

### 8.2 Operational Risks

| Risk | Severity | Likelihood | Mitigation |
|------|----------|------------|------------|
| **Breaking API changes** | Medium | Medium | Semver, deprecation warnings, changelog |
| **Adoption barrier** | Low | Low | Excellent docs, examples, migration guide |
| **Maintenance burden** | Low | Low | Clean architecture, good test coverage |
| **Security vulnerabilities** | Low | Low | Bandit scanning, security updates |

### 8.3 Business Risks

| Risk | Severity | Likelihood | Mitigation |
|------|----------|------------|------------|
| **Limited adoption** | Medium | Medium | Marketing, examples, showcase projects |
| **Terraform compatibility** | Low | Low | Compatibility tests, active maintenance |
| **Competition** | Low | Low | Unique Python implementation of go-cty |

---

## 9. Recommendations

### 9.1 Critical (Before Beta)

1. **‚úÖ PRIORITY 1: Add module docstrings**
   - Impact: High (improves API docs)
   - Effort: Medium (~56 files)
   - Files affected: All implementation files in `src/pyvider/cty/`

2. **‚úÖ PRIORITY 2: Performance profiling**
   - Impact: High (validates scalability claims)
   - Effort: Medium (2-3 days)
   - Deliverable: Performance benchmarks document

3. **‚úÖ PRIORITY 3: provide-foundation dependency review**
   - Impact: High (affects portability)
   - Effort: High (vendoring or public release)
   - Decision needed: Keep as-is, vendor, or make public

### 9.2 Important (Before GA 1.0)

4. **Document beta/GA criteria**
   - Define clear requirements for promotion
   - API stability guarantees
   - Performance baselines

5. **Expand performance tests**
   - Large dataset benchmarks (100K+ items)
   - Deep nesting tests (100+ levels)
   - Memory profiling

6. **Publish benchmark results**
   - Create benchmarks/ directory with results
   - Include in documentation
   - Compare with go-cty if possible

7. **API stability review**
   - Lock down public API for 1.0
   - Mark experimental features clearly
   - Document deprecation policy

### 9.3 Nice to Have (Post-GA)

8. **Additional function coverage**
   - Complete go-cty function parity
   - Document any intentional omissions

9. **Performance optimization**
   - Profile hot paths
   - Optimize large dataset handling
   - Consider Cython for critical paths (if needed)

10. **Enhanced documentation**
    - Video tutorials
    - More real-world examples
    - Case studies

11. **Community building**
    - Discord/Slack community
    - Regular blog posts
    - Conference talks

---

## 10. Comparative Analysis

### 10.1 vs go-cty (Upstream)

| Aspect | go-cty | pyvider-cty | Notes |
|--------|--------|-------------|-------|
| **Language** | Go | Python | Native to each ecosystem |
| **Type System** | Complete | Complete | Full parity |
| **Functions** | ~80 | 72 | Near parity, growing |
| **Serialization** | MessagePack/JSON | MessagePack/JSON | Compatible |
| **Performance** | Faster | Good | Expected (Go vs Python) |
| **Type Safety** | Compile-time | Runtime + mypy | Both effective |
| **Documentation** | Good | Excellent | More comprehensive |
| **Testing** | Good | Excellent | 94% coverage |

### 10.2 vs Similar Projects

**No direct competitors** - pyvider-cty is the only Python implementation of go-cty type system.

**Similar in spirit:**
- **Pydantic**: Data validation (but different domain)
- **Marshmallow**: Serialization (but less type-focused)
- **attrs**: Data classes (used by pyvider-cty)

**Unique value proposition:**
- ‚úÖ Terraform ecosystem compatibility
- ‚úÖ go-cty type system fidelity
- ‚úÖ MessagePack cross-language serialization

---

## 11. Conclusion

### 11.1 Summary Assessment

**pyvider-cty is a professionally engineered, production-quality implementation** of the go-cty type system for Python. The codebase demonstrates:

- ‚úÖ **Exceptional code quality** - 100% type safety, strict linting, clean architecture
- ‚úÖ **Comprehensive testing** - 94% coverage, property-based tests, cross-language verification
- ‚úÖ **Excellent documentation** - 46 docs, complete guides, API reference, examples
- ‚úÖ **Modern tooling** - uv, ruff, mypy, pytest, CI/CD
- ‚úÖ **Security** - Clean scans, validated inputs, no vulnerabilities
- ‚úÖ **Developer experience** - Pythonic API, one-command setup, clear docs

**Alpha designation is appropriate** given:
- ‚ö†Ô∏è API may still evolve
- ‚ö†Ô∏è Performance optimization ongoing
- ‚ö†Ô∏è Module documentation incomplete

**However, core implementation is production-ready:**
- ‚úÖ Solid architecture
- ‚úÖ Comprehensive tests
- ‚úÖ Type-safe throughout
- ‚úÖ Security verified

### 11.2 Go/No-Go Assessment

**RECOMMENDATION: STRONG GO** for continued development toward production release.

**Confidence Level: 95%**

**Rationale:**
1. **Technical excellence** - Architecture, code quality, testing are exemplary
2. **Clear path forward** - Recommendations are actionable and scoped
3. **Low technical debt** - Clean code, good practices throughout
4. **Strong foundation** - Ready for beta with minor improvements
5. **Enterprise suitable** - Security, scalability, maintainability verified

### 11.3 Roadmap Suggestion

**Phase 1: Beta (2-4 weeks)**
- Complete module docstrings
- Performance profiling and documentation
- Resolve provide-foundation dependency strategy
- Define API stability guarantees

**Phase 2: Release Candidate (4-6 weeks)**
- API freeze
- Performance optimization (if needed)
- Expand benchmark suite
- External beta testing

**Phase 3: GA 1.0.0 (2-4 weeks)**
- Final documentation review
- Release notes
- Marketing materials
- Community launch

**Estimated Timeline: 8-14 weeks to GA 1.0.0**

---

## 12. Stakeholder-Specific Summaries

### For Executives

**Bottom Line:** pyvider-cty is ready for beta promotion with minor documentation completion. The project demonstrates exceptional engineering quality and is on track for production release within 3 months.

**Key Metrics:**
- 94% test coverage
- 100% type safety
- 0 security vulnerabilities
- 46 documentation pages
- Alpha ‚Üí Beta ‚Üí GA path clear

**Investment Required:** 8-14 weeks of development effort to reach GA 1.0.0

**Business Value:**
- Enables Python developers to work with Terraform ecosystem
- Unique market position (no competitors)
- Strong technical foundation for future growth

### For Architects

**Architecture Pattern:** Clean layered architecture with Protocol+ABC type system, immutable values, generic types, and cross-language serialization.

**Key Design Decisions:**
- ‚úÖ Immutability via attrs frozen classes
- ‚úÖ Generic type system with covariance
- ‚úÖ MessagePack for cross-language compatibility
- ‚úÖ Centralized configuration (no hardcoded values)
- ‚úÖ Error boundaries for failure isolation

**Integration Points:**
- Terraform providers (primary use case)
- Python data validation pipelines
- Configuration management systems
- Cross-language IPC (Python ‚Üî Go)

**Technical Debt:** Minimal - primarily missing documentation

**Scalability:** Suitable for medium datasets; large-scale use requires profiling

### For Developers

**What Works Well:**
- ‚úÖ One-command setup (`uv sync`)
- ‚úÖ Fast feedback loop (ruff, mypy are fast)
- ‚úÖ Excellent IDE support (full type hints)
- ‚úÖ Clear error messages
- ‚úÖ Comprehensive examples
- ‚úÖ Easy to extend

**What Needs Work:**
- ‚ö†Ô∏è Module docstrings incomplete
- ‚ö†Ô∏è Performance characteristics undocumented
- ‚ö†Ô∏è Some API methods return `CtyValue[Any]` (type system limitation)

**How to Contribute:**
1. Read CONTRIBUTING.md (comprehensive guide)
2. Pick an issue or propose feature
3. Follow TDD approach (tests first)
4. Run `./validate-pipeline.sh` before PR
5. Pre-commit hooks ensure quality

**Community:** GitHub issues, PRs welcome, maintainers responsive

---

## Appendices

### A. File Inventory

- **Source Files**: 56 Python files (~7,367 LOC)
- **Test Files**: 154 Python files
- **Documentation**: 46 Markdown files
- **Examples**: 16 Python files
- **Config Files**: pyproject.toml, VERSION, .pre-commit-config.yaml, mkdocs.yml
- **CI/CD**: 3 GitHub Actions workflows

### B. Dependency Analysis

**Runtime Dependencies:**
- `attrs >= 25.1.0` - Data class implementation
- `msgpack >= 1.1.0` - Binary serialization
- `provide-foundation` - Logging, error boundaries

**Development Dependencies:**
- `provide-testkit[standard,advanced-testing,typecheck,build]` - Comprehensive dev tools

**Dependency Health:**
- ‚úÖ All dependencies actively maintained
- ‚úÖ Version constraints appropriate
- ‚ö†Ô∏è provide-foundation is path dependency (portability concern)

### C. Metrics Summary

| Metric | Value | Target | Status |
|--------|-------|--------|--------|
| Test Coverage | 94% | 75%+ | ‚úÖ Exceeds |
| Type Safety | 100% | 100% | ‚úÖ Perfect |
| Security Issues | 0 | 0 | ‚úÖ Clean |
| Documentation Files | 46 | 40+ | ‚úÖ Excellent |
| Test Files | 154 | 100+ | ‚úÖ Comprehensive |
| CI/CD Workflows | 3 | 2+ | ‚úÖ Complete |

### D. References

- **Repository**: https://github.com/provide-io/pyvider-cty
- **go-cty (upstream)**: https://github.com/zclconf/go-cty
- **Python Version**: 3.11+
- **License**: Apache License 2.0
- **Version Analyzed**: 0.0.1026

---

**Report Prepared By**: Architectural Analysis Agent
**Analysis Date**: November 12, 2025
**Report Version**: 1.0
**Next Review**: Upon beta release
>>> EOF >>>

### FILE 16: archive/SUPPLEMENTARY_ANALYSIS.md | checksum=e0d08b6b1e98... | modified=2025-11-15T19:04:27 | op=+ | size=34347 | tokens=8739 | type=markdown ###
<<< BOF <<<
# pyvider-cty: Supplementary Architectural Analysis

**Companion Document to**: ARCHITECTURAL_ANALYSIS.md
**Analysis Date**: November 12, 2025
**Version Analyzed**: 0.0.1026 (Alpha)

---

## Purpose

This document covers additional architectural considerations not fully addressed in the primary analysis, including legal compliance, security policies, concurrency models, supply chain security, observability, governance, and extensibility.

---

## 1. Legal & Licensing Compliance

### 1.1 License Analysis

**Primary License**: Apache License 2.0 (Apache-2.0)

**License Characteristics:**
- ‚úÖ **Permissive** - Commercial use allowed
- ‚úÖ **Patent grant** - Explicit patent license included
- ‚úÖ **Attribution required** - Must retain copyright notices
- ‚úÖ **Modification allowed** - Can create derivative works
- ‚úÖ **Sublicensing allowed** - Can redistribute under different terms
- ‚úÖ **Trademark protection** - Explicit trademark clause (Section 6)
- ‚úÖ **Liability limitation** - "AS IS" with no warranties

**Enterprise Implications:**
- ‚úÖ **Safe for commercial use** - No copyleft restrictions
- ‚úÖ **Patent protection** - Contributors grant patent rights
- ‚úÖ **Clear liability terms** - No implied warranties
- ‚úÖ **Trademark clarity** - Cannot use provide.io trademarks without permission

### 1.2 Copyright & Attribution

**Copyright Holder**: provide.io llc (Copyright 2025)

**SPDX Headers:**
- ‚úÖ **All source files** - 112/112 files have SPDX headers
- ‚úÖ **Consistent format**:
  ```
  # SPDX-FileCopyrightText: Copyright (c) 2025 provide.io llc. All rights reserved.
  # SPDX-License-Identifier: Apache-2.0
  ```
- ‚úÖ **Machine-readable** - SPDX format enables automated compliance

**Strengths:**
- ‚úÖ Complete copyright attribution
- ‚úÖ SPDX compliance for supply chain transparency
- ‚úÖ No ambiguous or missing headers

**Recommendations:**
1. ‚úÖ **APPROVED**: License structure is enterprise-ready
2. Consider adding NOTICE file for third-party attributions (Apache 2.0 Section 4.d)

### 1.3 Dependency License Compatibility

**Runtime Dependencies:**
- `attrs >= 25.1.0` - **MIT License** ‚úÖ Compatible
- `msgpack >= 1.1.0` - **Apache License 2.0** ‚úÖ Compatible
- `provide-foundation` - **Unknown** ‚ö†Ô∏è Needs verification

**Assessment:**
- ‚úÖ All known dependencies use permissive licenses
- ‚ö†Ô∏è **ACTION REQUIRED**: Verify provide-foundation license compatibility

**Recommendation**: Create `LICENSE-THIRD-PARTY.md` listing all dependencies and their licenses.

### 1.4 Contributor License Agreement (CLA)

**Current State**: No CLA mentioned in CONTRIBUTING.md

**CONTRIBUTING.md states**:
> "By contributing, you agree that your contributions will be licensed under the Apache License 2.0."

**Assessment:**
- ‚úÖ **Sufficient for open source** - Apache 2.0 Section 5 covers contributions
- ‚ö†Ô∏è **No explicit CLA** - May complicate corporate contributions
- ‚úÖ **Clear license statement** - Contributors understand terms

**Recommendation for GA:**
- For corporate/enterprise adoption, consider explicit CLA or DCO (Developer Certificate of Origin)
- DCO is lighter-weight and widely accepted (used by Linux kernel)

### 1.5 Export Control & Compliance

**Cryptography Usage**: MessagePack serialization only (no encryption)

**Assessment**:
- ‚úÖ **No export restrictions** - No cryptographic functionality
- ‚úÖ **Safe for international use** - Pure data validation library

---

## 2. Security Policy & Vulnerability Management

### 2.1 Security Disclosure Policy

**Current State**: ‚ùå **No SECURITY.md file found**

**Impact:**
- ‚ö†Ô∏è No documented process for reporting vulnerabilities
- ‚ö†Ô∏è Unclear response timeline expectations
- ‚ö†Ô∏è No designated security contact

**CRITICAL RECOMMENDATION**: Create SECURITY.md with:
```markdown
# Security Policy

## Supported Versions
| Version | Supported          |
|---------|--------------------|
| 0.0.x   | :white_check_mark: |

## Reporting a Vulnerability
Please report security vulnerabilities to: security@provide.io

**Do not** open public issues for security vulnerabilities.

Expected response time: 48 hours
Expected resolution timeline: 30 days for critical issues

## Security Update Policy
Security updates will be released as patch versions and announced via:
- GitHub Security Advisories
- Release notes
- Email to security mailing list (if established)
```

### 2.2 Vulnerability Scanning

**Current Measures:**
- ‚úÖ **Bandit** - Static security analysis (clean scan)
- ‚úÖ **Pre-commit hooks** - Prevent debug statements, detect secrets
- ‚úÖ **CI/CD security job** - Optional security scanning in workflows
- ‚ö†Ô∏è **No dependency scanning** - No automated CVE checking

**Recommendations:**
1. **Add Dependabot** - Automated dependency vulnerability alerts
   ```yaml
   # .github/dependabot.yml
   version: 2
   updates:
     - package-ecosystem: "pip"
       directory: "/"
       schedule:
         interval: "weekly"
   ```

2. **Add Safety** - Python dependency vulnerability checker
   ```bash
   uv pip install safety
   safety check --json
   ```

3. **GitHub Code Scanning** - Enable CodeQL for advanced analysis

### 2.3 Security Best Practices in Code

**Input Validation:**
- ‚úÖ All external inputs validated at type boundaries
- ‚úÖ No eval/exec usage found
- ‚úÖ No SQL injection vectors (no database access)
- ‚úÖ No command injection vectors
- ‚úÖ Path traversal prevented (no filesystem operations based on user input)

**Resource Limits:**
- ‚úÖ Recursion depth limits (500 max)
- ‚úÖ Validation timeout (30 seconds)
- ‚úÖ Object revisit limits (prevents DoS via circular references)

**Thread Safety:**
- ‚úÖ Thread-local context for validation
- ‚úÖ ContextVars for caching (thread-safe)
- ‚úÖ Immutable data structures (CtyValue frozen)

**Assessment**: ‚úÖ **Security-conscious design throughout**

---

## 3. Backward Compatibility & Versioning Strategy

### 3.1 Current Versioning

**Version**: 0.0.1026 (Alpha)
**Classification**: Development Status :: 3 - Alpha
**Semantic Versioning**: Not yet enforced (0.x allows breaking changes)

### 3.2 API Stability Guarantees

**Current State**: Alpha - No stability guarantees

**Public API Surface** (from `__all__`):
- **Types**: 10 classes (CtyBool, CtyString, CtyNumber, etc.)
- **Values**: 1 class (CtyValue)
- **Exceptions**: 8 classes
- **Functions**: 4 utilities (convert, unify, parse functions)
- **Marks**: 1 class (CtyMark)

**Total Public API**: ~24 exported symbols

### 3.3 Breaking Change Risk Assessment

**Low Risk** (stable patterns):
- ‚úÖ Core type system (primitives, collections, structural)
- ‚úÖ Value immutability contract
- ‚úÖ Serialization wire format (must maintain go-cty compatibility)
- ‚úÖ Exception hierarchy

**Medium Risk** (may evolve):
- ‚ö†Ô∏è Function library API (adding functions is safe, changing signatures is breaking)
- ‚ö†Ô∏è Conversion/unification algorithms (optimization may change behavior)
- ‚ö†Ô∏è Parser features (Terraform syntax evolution)

**High Risk** (likely to change):
- ‚ö†Ô∏è Internal APIs (not in `__all__`)
- ‚ö†Ô∏è Configuration system (runtime.py, defaults.py)
- ‚ö†Ô∏è Performance characteristics (optimization may change timing)

### 3.4 Deprecation Policy

**Current State**: ‚ùå No documented deprecation policy

**Recommendation for Beta**:
```python
# Example deprecation pattern
import warnings

@deprecated(version="0.2.0", removal="1.0.0", alternative="new_function")
def old_function():
    warnings.warn(
        "old_function is deprecated and will be removed in 1.0.0. Use new_function instead.",
        DeprecationWarning,
        stacklevel=2
    )
```

**Proposed Policy for 1.0+**:
1. **Deprecation warnings** - 1 minor version minimum before removal
2. **Documentation** - Mark deprecated items in docs
3. **Changelog** - List all deprecations prominently
4. **Migration guide** - Provide upgrade paths

### 3.5 Version Compatibility Matrix

**Proposed for GA**:

| pyvider-cty | Python | go-cty | Terraform |
|-------------|--------|--------|-----------|
| 0.x (Alpha) | 3.11-3.14 | Compatible* | 1.0+ |
| 1.0 (GA)    | 3.11-3.14 | Compatible | 1.0+ |
| 2.0 (Future)| 3.12-3.15 | Compatible | 1.0+ |

*Wire format compatibility maintained

---

## 4. Concurrency, Thread Safety & Async Support

### 4.1 Threading Model

**Current Implementation**:
- ‚úÖ **Thread-safe by design** - Immutable values
- ‚úÖ **Thread-local contexts** - `threading.local()` for recursion detection
- ‚úÖ **ContextVars** - For inference caching (thread-safe and async-safe)

**Evidence from Code**:

```python
# src/pyvider/cty/validation/recursion.py:86
_thread_local = threading.local()

# src/pyvider/cty/conversion/inference_cache.py:28
_structural_key_cache = ContextScopedCache[int, tuple[Any, ...]]("structural_keys")
```

**Thread Safety Analysis**:

| Component | Thread-Safe? | Mechanism |
|-----------|--------------|-----------|
| **CtyValue** | ‚úÖ Yes | Immutable (`frozen=True`) |
| **CtyType** | ‚úÖ Yes | Immutable, no mutable state |
| **Validation Context** | ‚úÖ Yes | `threading.local()` |
| **Inference Cache** | ‚úÖ Yes | ContextVars |
| **Function Library** | ‚úÖ Yes | Pure functions, no shared state |

**Assessment**: ‚úÖ **Fully thread-safe**

### 4.2 Async Support

**Current State**: ‚ùå **No async support**

**Analysis**:
- No `async`/`await` found in source code
- No asyncio imports
- All functions are synchronous

**Use Case Assessment**:
- ‚úÖ **Not critical for current use cases** - Type validation is CPU-bound, not I/O-bound
- ‚úÖ **ContextVars support** - Infrastructure ready for async if needed
- ‚ö†Ô∏è **Potential future need** - Async Terraform provider integration

**Recommendation**:
- **Beta**: Document sync-only status
- **GA**: Evaluate based on user feedback
- **Future (2.0?)**: Add async variants if demand exists
  ```python
  async def validate_async(self, value: object) -> CtyValue[T]:
      # Async validation for I/O-bound scenarios
  ```

### 4.3 Multiprocessing Compatibility

**Assessment**: ‚úÖ **Should work** with caveats

**Considerations**:
- ‚úÖ **Immutable values** - Safe to pass across process boundaries
- ‚úÖ **No global state** - Each process gets own context
- ‚ö†Ô∏è **Serialization overhead** - Pickle may be inefficient for large structures
- ‚úÖ **MessagePack support** - Can use for efficient IPC

**Recommendation**: Add multiprocessing example and test to validate compatibility.

### 4.4 Concurrency Best Practices

**Guidance for Users**:

```python
# Thread-safe usage (recommended)
from concurrent.futures import ThreadPoolExecutor

def validate_item(item):
    return user_type.validate(item)

with ThreadPoolExecutor() as executor:
    results = executor.map(validate_item, items)
```

**Documentation Needed**:
- Thread safety guarantees
- Async roadmap (or lack thereof)
- Multiprocessing guidance

---

## 5. Supply Chain Security

### 5.1 Software Bill of Materials (SBOM)

**Current State**: ‚ùå **No SBOM generation**

**Impact**:
- ‚ö†Ô∏è Difficult for enterprises to audit dependencies
- ‚ö†Ô∏è No machine-readable supply chain inventory
- ‚ö†Ô∏è Compliance challenges (e.g., EO 14028 for government)

**Recommendation**: Add SBOM generation to release workflow

```yaml
# .github/workflows/release.yml addition
- name: Generate SBOM
  uses: anchore/sbom-action@v0
  with:
    format: spdx-json
    output-file: pyvider-cty-sbom.spdx.json

- name: Upload SBOM
  uses: actions/upload-artifact@v4
  with:
    name: sbom
    path: pyvider-cty-sbom.spdx.json
```

**Tools to Consider**:
- CycloneDX (Python-specific tooling)
- SPDX (industry standard)
- Syft (anchore/sbom-action uses this)

### 5.2 Build Provenance

**Current State**: ‚ö†Ô∏è **Partial provenance**

**What Exists**:
- ‚úÖ GitHub Actions CI/CD (verifiable build environment)
- ‚úÖ Trusted publishing to PyPI (no token needed)
- ‚úÖ Git commit signatures possible

**What's Missing**:
- ‚ùå SLSA provenance attestations
- ‚ùå Signed artifacts
- ‚ùå Build reproducibility guarantees

**Recommendation**: Add SLSA provenance for GA

```yaml
# .github/workflows/release.yml addition
- name: Generate provenance
  uses: slsa-framework/slsa-github-generator/.github/workflows/generator_generic_slsa3.yml@v1
```

### 5.3 Dependency Pinning & Lock Files

**Current State**: ‚úÖ **Good**

- ‚úÖ `uv.lock` - Locks all transitive dependencies
- ‚úÖ Version ranges in `pyproject.toml` - Not overly restrictive
- ‚úÖ Upper bounds specified - Prevents surprise breakage

**Lock File Coverage**:
```toml
# Runtime dependencies pinned via uv.lock
attrs>=25.1.0
msgpack>=1.1.0
provide-foundation (path dependency)
```

**Recommendation**: ‚úÖ Current approach is best practice

### 5.4 Dependency Confusion Attacks

**Risk Assessment**: ‚ö†Ô∏è **Medium risk**

**Vulnerability**: `provide-foundation` is a path dependency
- If a malicious `provide-foundation` appears on PyPI, could be installed instead
- Users outside the monorepo may encounter issues

**Mitigation**:
1. **Document the dependency** - Explain it's internal
2. **Consider vendoring** - Include in package
3. **Or make it public** - Publish to PyPI with unique name
4. **Use PEP 708** (future) - Private dependency index

**Recommendation**: Resolve provide-foundation distribution before GA

### 5.5 Artifact Signing

**Current State**: ‚ùå **Artifacts not signed**

**Impact**:
- ‚ö†Ô∏è No cryptographic proof of authenticity
- ‚ö†Ô∏è No tamper detection
- ‚ö†Ô∏è Compliance gaps for some enterprises

**Recommendation for GA**:
```bash
# Sign wheel with sigstore
pip install sigstore
python -m sigstore sign pyvider_cty-*.whl
```

Or use GPG signing:
```bash
gpg --detach-sign --armor pyvider_cty-*.whl
```

---

## 6. Observability & Debugging

### 6.1 Logging Infrastructure

**Current Implementation**:
- ‚úÖ **Integrated logging** - Uses `provide.foundation.logger`
- ‚úÖ **Structured logging** - Key-value pairs
- ‚úÖ **Contextual information** - Includes paths, types, metrics

**Evidence**:
```python
# src/pyvider/cty/validation/recursion.py:152
logger.warning(
    "CTY validation depth limit exceeded",
    current_depth=current_depth,
    max_allowed=self.context.max_depth_allowed,
    path=current_path,
    trace="advanced_recursion_detection",
)
```

**Log Levels Used**:
- `logger.debug()` - Detailed validation flow
- `logger.warning()` - Recursion limits, timeouts
- `logger.error()` (via error_boundary) - Exceptions

**Strengths**:
- ‚úÖ **Rich context** - All log messages include relevant metadata
- ‚úÖ **Trace markers** - `trace="advanced_recursion_detection"` for filtering
- ‚úÖ **Test-safe** - `configure_foundation_logger_for_tests()` fixture

**Recommendations**:
1. Document logging configuration for users
2. Provide examples of log filtering/analysis
3. Consider log level recommendations for production

### 6.2 Performance Metrics

**Built-in Metrics** (from RecursionDetector):

```python
def get_performance_metrics(self) -> dict[str, Any]:
    return {
        "total_validations": self.context.total_validations,
        "max_depth_reached": self.context.max_depth_reached,
        "elapsed_ms": elapsed_ms,
        "objects_in_graph": len(self.context.validation_graph),
        "avg_validations_per_ms": ...,
        "current_path": self.get_current_path(),
    }
```

**Strengths**:
- ‚úÖ **Performance visibility** - Metrics available during validation
- ‚úÖ **Recursion tracking** - Depth and revisit counts
- ‚úÖ **Timing information** - Elapsed time tracking

**Gaps**:
- ‚ö†Ô∏è **No metric export** - Metrics not exposed via API
- ‚ö†Ô∏è **No telemetry** - No Prometheus/OpenTelemetry integration
- ‚ö†Ô∏è **No profiling helpers** - Users must bring own tools

**Recommendations**:
1. Expose performance metrics via public API
2. Add optional telemetry integration (OpenTelemetry)
3. Provide profiling guide in docs

### 6.3 Error Diagnostics

**Error Context**:
- ‚úÖ **Rich exceptions** - 21 exception types
- ‚úÖ **Path tracking** - Validation errors include paths
- ‚úÖ **Error boundaries** - Integration with provide.foundation

**Example Error Message**:
```python
# Well-formed error with context
ERR_CANNOT_COMPARE_DIFFERENT_TYPES = (
    "Cannot compare CtyValues of different types: {type1} vs {type2}"
)
```

**Strengths**:
- ‚úÖ **Clear messages** - User-friendly error text
- ‚úÖ **Template-based** - Consistent formatting
- ‚úÖ **Path information** - Shows where validation failed

**Gaps**:
- ‚ö†Ô∏è **No error codes** - Difficult for programmatic handling
- ‚ö†Ô∏è **No error catalog** - No comprehensive error reference

**Recommendations**:
1. Add error codes to exceptions (e.g., `CTY-E-001`)
2. Create error catalog documentation
3. Add troubleshooting guide with common errors

### 6.4 Debugging Tools

**Current State**: ‚ö†Ô∏è **Limited debugging support**

**Available**:
- ‚úÖ **repr() methods** - Human-readable representations
- ‚úÖ **Validation paths** - Shows validation flow
- ‚úÖ **Performance metrics** - Internal visibility

**Missing**:
- ‚ùå **Debug mode** - No verbose debugging flag
- ‚ùå **Visualization** - No type/value tree visualization
- ‚ùå **Interactive debugger helpers** - No REPL-friendly utilities

**Recommendations**:
```python
# Proposed debug utilities
from pyvider.cty.debug import (
    visualize_type_tree,    # ASCII art of type structure
    explain_validation,     # Step-by-step validation trace
    diff_values,           # Compare two CtyValues
)
```

---

## 7. Community Governance & Support Model

### 7.1 Project Governance

**Current State**: ‚ö†Ô∏è **Informal governance**

**What Exists**:
- ‚úÖ **Clear ownership** - provide.io llc
- ‚úÖ **Maintainer identified** - provide.io (email: code@provide.io)
- ‚úÖ **Contributing guide** - CONTRIBUTING.md

**What's Missing**:
- ‚ùå **Governance model** - No GOVERNANCE.md
- ‚ùå **Decision-making process** - Unclear how decisions are made
- ‚ùå **Committer criteria** - No path to becoming a maintainer
- ‚ùå **Code of Conduct** - No CODE_OF_CONDUCT.md

**Recommendation**: For GA, add minimal governance structure

```markdown
# GOVERNANCE.md (proposed)

## Project Roles
- **Maintainers**: Core team with commit access (currently: provide.io)
- **Contributors**: Anyone who submits PRs
- **Users**: Everyone using the library

## Decision Making
- Minor changes: Maintainer approval
- Major changes: RFC process (GitHub Discussion)
- Breaking changes: Require broader community input

## Becoming a Maintainer
- Consistent high-quality contributions
- Domain expertise
- Invitation by existing maintainers
```

### 7.2 Code of Conduct

**Current State**: ‚ùå **No CODE_OF_CONDUCT.md**

**Impact**:
- ‚ö†Ô∏è **Community expectations unclear** - No defined behavior standards
- ‚ö†Ô∏è **Incident handling undefined** - No process for violations
- ‚ö†Ô∏è **Reduced inclusivity** - May discourage diverse contributors

**Recommendation**: Adopt standard Code of Conduct

**Options**:
1. **Contributor Covenant** (most popular, used by 200K+ projects)
2. **Citizen Code of Conduct**
3. **Custom code based on industry standards**

**Priority**: ‚úÖ **Add before GA** (especially for enterprise adoption)

### 7.3 Support Channels

**Current State**: ‚ö†Ô∏è **Limited support infrastructure**

**What Exists**:
- ‚úÖ **GitHub Issues** - Bug reports and features
- ‚úÖ **Issue templates** - Bug report, feature request
- ‚úÖ **Documentation** - Comprehensive guides

**What's Missing**:
- ‚ùå **Discussion forum** - No GitHub Discussions enabled
- ‚ùå **Chat/Slack/Discord** - No real-time support
- ‚ùå **Mailing list** - No email-based community
- ‚ùå **Stack Overflow tag** - No dedicated Q&A
- ‚ùå **Support SLA** - No response time commitments

**Recommendation Matrix**:

| Channel | Priority | Benefit |
|---------|----------|---------|
| GitHub Discussions | High | Low-overhead, integrated |
| Discord/Slack | Medium | Real-time help, community building |
| Stack Overflow tag | Low | SEO, broader visibility |
| Mailing list | Low | Traditional users, announcements |

**Minimal Viable Support** (for Beta):
- Enable GitHub Discussions (free, easy)
- Create discussion categories: Q&A, Ideas, Show & Tell

### 7.4 Release Communication

**Current State**: ‚úÖ **Adequate**

- ‚úÖ **CHANGELOG.md** - Documents all changes
- ‚úÖ **GitHub Releases** - Auto-generated release notes
- ‚úÖ **Version tags** - Git tags for each release

**Recommendations**:
1. **Security mailing list** - For critical security updates
2. **Release blog posts** - For major versions (optional)
3. **Twitter/social** - Announce major releases (optional)

---

## 8. Ecosystem Integration Opportunities

### 8.1 Python Ecosystem

**Current Integrations**:
- ‚úÖ **PyPI** - Standard distribution
- ‚úÖ **Type hints** - Full mypy integration
- ‚úÖ **pytest** - Testing framework

**Potential Integrations**:

| Tool/Framework | Opportunity | Priority | Effort |
|----------------|-------------|----------|--------|
| **Pydantic** | Interop with Pydantic models | High | Medium |
| **FastAPI** | API schema validation | Medium | Low |
| **attrs/dataclasses** | Type conversion helpers | Medium | Low |
| **Django/Flask** | Form validation | Low | High |
| **Jupyter** | Interactive notebooks | Medium | Low |
| **Type stubs** | Improved IDE support | High | Low |

**High-Value Integration: Pydantic**

```python
# Example interop
from pydantic import BaseModel
from pyvider.cty import CtyObject, CtyString, CtyNumber

class User(BaseModel):
    name: str
    age: int

# Convert Pydantic model to CtyObject
user_cty_type = pydantic_to_cty(User)
```

**Recommendation**: Create `pyvider.cty.integrations` module

### 8.2 Terraform Ecosystem

**Current Status**: ‚úÖ **Wire format compatible**

**Opportunities**:
1. **terraform-plugin-framework** - Python provider SDK
2. **Terraform Cloud** - API integration
3. **Sentinel** - Policy as code integration
4. **CDK for Terraform** - Python CDKTF support

**Example Use Case**:
```python
# Python Terraform provider using pyvider-cty
from pyvider.cty import CtyObject, CtyString
import terraform_plugin_framework as tpf

class UserResource(tpf.Resource):
    schema = CtyObject(
        attribute_types={
            "name": CtyString(),
            "email": CtyString(),
        }
    )
```

**Recommendation**: Create example Terraform provider using pyvider-cty

### 8.3 Data Validation Ecosystem

**Position**: Unique niche - Terraform-compatible validation

**Competitors/Complements**:
- **Pydantic** - General data validation (most popular)
- **Marshmallow** - Serialization (established)
- **Cerberus** - Schema validation
- **jsonschema** - JSON Schema validation

**Differentiation**:
- ‚úÖ **Terraform compatibility** - Unique value proposition
- ‚úÖ **go-cty semantics** - Matches upstream behavior
- ‚úÖ **MessagePack wire format** - Cross-language IPC
- ‚úÖ **Unknown/null handling** - Terraform planning semantics

**Recommendation**: Position as "Terraform-native validation for Python"

### 8.4 CI/CD Integration

**GitHub Actions Integration**:
```yaml
# Example: Validate Terraform configs with pyvider-cty
- name: Validate Terraform data
  run: |
    uv pip install pyvider-cty
    python validate-tf-data.py
```

**Potential Actions to Build**:
1. `pyvider-cty/validate-action` - Pre-built validation action
2. `pyvider-cty/type-check-action` - Type checking for configs

---

## 9. Memory Footprint & Resource Usage

### 9.1 Memory Characteristics

**Design Choices Affecting Memory**:
- ‚úÖ **`__slots__`** - Reduces per-instance memory (~40% savings)
- ‚úÖ **Immutable structures** - No defensive copies needed
- ‚ö†Ô∏è **Caching** - Type inference cache uses memory
- ‚ö†Ô∏è **Validation graph** - Stores object IDs during validation

**Estimated Memory per CtyValue**:
```python
# Without slots: ~56 bytes + dict overhead (~240 bytes) = ~296 bytes
# With slots: ~56 bytes + 5 slot pointers (~40 bytes) = ~96 bytes
```

**Savings**: ~67% per instance with `__slots__`

### 9.2 Large Dataset Handling

**Current Limitations** (from README):
> "Not yet optimized for very large or deeply nested data structures"

**Specific Concerns**:
- ‚ö†Ô∏è **Deep recursion** - Stack depth limits (500 default)
- ‚ö†Ô∏è **Large collections** - O(n) validation, no streaming
- ‚ö†Ô∏è **Serialization** - Entire structure in memory

**Recommendations**:
1. **Benchmark large datasets** - Document practical limits
2. **Add streaming validation** - For large collections
3. **Pagination support** - For incremental processing

**Example Enhancement**:
```python
# Proposed streaming API
def validate_stream(type: CtyList, items: Iterator) -> Iterator[CtyValue]:
    for item in items:
        yield type.element_type.validate(item)
```

### 9.3 Memory Leak Prevention

**Risk Areas**:
- ‚úÖ **Cache management** - ContextVars auto-cleanup
- ‚úÖ **Validation context** - Thread-local, properly cleared
- ‚úÖ **Immutability** - No retained references

**Testing**:
- ‚ö†Ô∏è **No memory leak tests** - No long-running validation tests
- ‚ö†Ô∏è **No memory profiling** - No memory benchmarks

**Recommendation**: Add memory leak test
```python
import gc
import tracemalloc

def test_no_memory_leak():
    tracemalloc.start()

    for _ in range(10000):
        val = user_type.validate(data)
        del val

    gc.collect()
    current, peak = tracemalloc.get_traced_memory()
    assert current < 10 * 1024 * 1024  # < 10MB
```

### 9.4 Resource Limits & Configuration

**Configurable Limits** (from config/defaults.py):
- `MAX_VALIDATION_DEPTH = 500` - Recursion depth
- `MAX_OBJECT_REVISITS = 3` - Circular reference detection
- `MAX_VALIDATION_TIME_MS = 30000` - Timeout (30 seconds)

**Strengths**:
- ‚úÖ **Configurable** - Can adjust for specific use cases
- ‚úÖ **Sensible defaults** - Balance safety and usability
- ‚úÖ **Multiple safeguards** - Depth, time, revisit limits

**Recommendation**: Document tuning guidance
```python
# Example: High-performance tuning
from pyvider.cty.config.runtime import CtyConfig

config = CtyConfig(
    max_validation_depth=1000,  # Deeper nesting allowed
    max_object_revisits=10,     # More complex graphs
    enable_type_inference_cache=True,  # Performance boost
)
```

---

## 10. Extensibility & Plugin Architecture

### 10.1 Custom Type Creation

**Current Mechanism**: `CtyCapsule` and `CtyCapsuleWithOps`

**Example**:
```python
from pyvider.cty import CtyCapsule, CtyCapsuleWithOps

# Simple opaque type
class UUIDCapsule(CtyCapsule):
    def __init__(self):
        super().__init__(name="UUID", python_type=uuid.UUID)

# With custom operations
class UUIDCapsuleWithOps(CtyCapsuleWithOps):
    def __init__(self):
        super().__init__(
            name="UUID",
            python_type=uuid.UUID,
            equal_fn=lambda a, b: a == b,
            hash_fn=lambda v: hash(v),
            convert_fn=lambda v, t: convert_uuid(v, t),
        )
```

**Strengths**:
- ‚úÖ **Well-documented pattern** - Clear extension point
- ‚úÖ **Flexible** - Supports custom equality, hashing, conversion
- ‚úÖ **Type-safe** - Validates python_type match

**Limitations**:
- ‚ö†Ô∏è **No plugin registry** - Can't discover custom types
- ‚ö†Ô∏è **No serialization hooks** - Capsules may not serialize well
- ‚ö†Ô∏è **Limited composition** - Hard to combine custom types

### 10.2 Custom Function Registration

**Current State**: ‚ùå **No function registration mechanism**

**All functions hardcoded** in `functions/` modules

**Recommendation**: Add function registry
```python
from pyvider.cty.functions import register_function

@register_function(
    name="my_custom_function",
    params=[CtyString(), CtyNumber()],
    return_type=CtyString(),
)
def my_function(s: CtyValue, n: CtyValue) -> CtyValue:
    # Custom function logic
    ...
```

### 10.3 Validation Hooks

**Current State**: ‚ö†Ô∏è **Limited hook points**

**Available**:
- ‚úÖ `@with_recursion_detection` decorator - Can wrap validation
- ‚ö†Ô∏è **No pre/post validation hooks**

**Recommendation**: Add validation lifecycle hooks
```python
class CtyType:
    def before_validate(self, value: object) -> object:
        """Hook called before validation. Can transform input."""
        return value

    def after_validate(self, result: CtyValue) -> CtyValue:
        """Hook called after validation. Can add marks, etc."""
        return result
```

### 10.4 Serialization Extensibility

**Current State**: ‚ö†Ô∏è **Fixed serialization formats**

**Supported**: JSON, MessagePack

**Extension Points**:
- ‚ö†Ô∏è **No codec registry** - Can't add custom formats
- ‚ö†Ô∏è **MessagePack extensions** - Limited to types 0, 12

**Recommendation**: Add codec registry
```python
from pyvider.cty.codec import register_codec

@register_codec(name="yaml")
class YAMLCodec:
    def encode(self, value: CtyValue) -> bytes:
        ...

    def decode(self, data: bytes) -> CtyValue:
        ...
```

### 10.5 Extensibility Assessment

| Extension Point | Exists? | Quality | Recommendation |
|-----------------|---------|---------|----------------|
| Custom types | ‚úÖ Yes | Good | Document better |
| Custom functions | ‚ùå No | N/A | Add registry |
| Validation hooks | ‚ö†Ô∏è Limited | Basic | Enhance lifecycle |
| Custom codecs | ‚ùå No | N/A | Add codec API |
| Type visitors | ‚ùå No | N/A | Consider for 2.0 |

**Overall**: ‚ö†Ô∏è **Moderate extensibility** - Good for types, limited elsewhere

---

## 11. Critical Gaps & Action Items

### 11.1 Security & Governance (HIGH PRIORITY)

1. **SECURITY.md** - Security disclosure policy
   - Priority: CRITICAL
   - Effort: 1 hour
   - Owner: Maintainers

2. **CODE_OF_CONDUCT.md** - Community standards
   - Priority: HIGH (before GA)
   - Effort: 30 minutes
   - Recommendation: Adopt Contributor Covenant

3. **Dependabot** - Automated vulnerability scanning
   - Priority: HIGH
   - Effort: 15 minutes
   - Implementation: .github/dependabot.yml

### 11.2 Supply Chain & Compliance (MEDIUM PRIORITY)

4. **SBOM Generation** - Software bill of materials
   - Priority: MEDIUM (for enterprise)
   - Effort: 2 hours
   - Tool: cyclonedx-bom or syft

5. **SLSA Provenance** - Build attestations
   - Priority: MEDIUM
   - Effort: 4 hours
   - Tool: slsa-github-generator

6. **Artifact Signing** - Cryptographic signatures
   - Priority: MEDIUM
   - Effort: 2 hours
   - Tool: sigstore or GPG

### 11.3 Community & Support (MEDIUM PRIORITY)

7. **GitHub Discussions** - Enable community forum
   - Priority: MEDIUM
   - Effort: 5 minutes
   - Action: Repository settings

8. **GOVERNANCE.md** - Project governance model
   - Priority: MEDIUM (before GA)
   - Effort: 2 hours

### 11.4 Observability & Debugging (LOW PRIORITY)

9. **Debug utilities** - Visualization, explain, diff
   - Priority: LOW
   - Effort: 8 hours
   - Module: pyvider.cty.debug

10. **Performance metrics API** - Expose internal metrics
    - Priority: LOW
    - Effort: 4 hours

---

## 12. Enterprise Readiness Checklist

| Requirement | Status | Notes |
|-------------|--------|-------|
| **Legal & Licensing** |
| Open source license | ‚úÖ Yes | Apache 2.0 |
| SPDX headers | ‚úÖ Yes | All 112 files |
| License compatibility | ‚ö†Ô∏è Partial | Verify provide-foundation |
| Third-party attribution | ‚ö†Ô∏è Missing | Create LICENSE-THIRD-PARTY.md |
| **Security** |
| Security policy | ‚ùå No | CRITICAL: Add SECURITY.md |
| Vulnerability scanning | ‚ö†Ô∏è Partial | Add Dependabot |
| Security audits | ‚ö†Ô∏è None | Consider for GA |
| Signed releases | ‚ùå No | Add for GA |
| **Compliance** |
| SBOM | ‚ùå No | Add for enterprise |
| Provenance | ‚ùå No | Add SLSA attestations |
| Export control | ‚úÖ N/A | No crypto |
| **Governance** |
| Code of Conduct | ‚ùå No | Add before GA |
| Governance model | ‚ùå No | Document for GA |
| Contribution process | ‚úÖ Yes | CONTRIBUTING.md |
| **Support** |
| Documentation | ‚úÖ Excellent | 46 docs |
| Issue templates | ‚úÖ Yes | Bug, feature |
| Community forum | ‚ùå No | Enable Discussions |
| SLA | ‚ùå No | Not required for OSS |
| **Quality** |
| Test coverage | ‚úÖ 94% | Excellent |
| Type safety | ‚úÖ 100% | mypy strict |
| CI/CD | ‚úÖ Yes | Comprehensive |
| **Observability** |
| Logging | ‚úÖ Yes | Structured logging |
| Metrics | ‚ö†Ô∏è Internal | Expose via API |
| Tracing | ‚ùå No | Optional for library |

**Enterprise Readiness Score**: 65/100

**Blockers for Enterprise Adoption**:
1. Missing SECURITY.md (CRITICAL)
2. No CODE_OF_CONDUCT.md (HIGH)
3. provide-foundation dependency unclear (MEDIUM)
4. No SBOM/provenance (MEDIUM for regulated industries)

---

## 13. Summary & Recommendations

### 13.1 Immediate Actions (Before Beta)

1. ‚úÖ **Create SECURITY.md** (1 hour) - CRITICAL
2. ‚úÖ **Add CODE_OF_CONDUCT.md** (30 min) - HIGH
3. ‚úÖ **Enable GitHub Discussions** (5 min) - MEDIUM
4. ‚úÖ **Add Dependabot** (15 min) - HIGH
5. ‚úÖ **Document provide-foundation dependency** (30 min) - MEDIUM

**Total Effort**: ~3 hours

### 13.2 Beta Preparation (Next 2-4 weeks)

6. ‚úÖ **Create LICENSE-THIRD-PARTY.md** (2 hours)
7. ‚úÖ **Add GOVERNANCE.md** (2 hours)
8. ‚úÖ **Document thread safety guarantees** (2 hours)
9. ‚úÖ **Add SBOM generation** (2 hours)
10. ‚úÖ **Performance profiling & documentation** (8 hours)

**Total Effort**: ~16 hours

### 13.3 GA Preparation (Before 1.0)

11. ‚úÖ **SLSA provenance** (4 hours)
12. ‚úÖ **Artifact signing** (2 hours)
13. ‚úÖ **Resolve provide-foundation distribution** (variable)
14. ‚úÖ **Add deprecation utilities** (4 hours)
15. ‚úÖ **Create debug utilities module** (8 hours)

**Total Effort**: ~18 hours + dependency resolution

### 13.4 Overall Assessment

**Thread Safety**: ‚úÖ EXCELLENT - Fully thread-safe, ContextVars ready for async
**Security Posture**: ‚ö†Ô∏è GOOD - Clean code, needs policy documentation
**Supply Chain**: ‚ö†Ô∏è MODERATE - No SBOM/provenance, signed releases needed
**Observability**: ‚úÖ GOOD - Structured logging, internal metrics available
**Extensibility**: ‚ö†Ô∏è MODERATE - Good for custom types, limited elsewhere
**Governance**: ‚ö†Ô∏è BASIC - Needs formal structure before GA
**Legal Compliance**: ‚úÖ EXCELLENT - Apache 2.0, SPDX headers everywhere

**RECOMMENDATION**: Address critical security/governance gaps (SECURITY.md, CODE_OF_CONDUCT.md) immediately, then proceed with beta release while working on supply chain security for GA.

---

**Document End**
>>> EOF >>>

### FILE 17: getting-started/examples.md | checksum=08e7eda9e2e0... | modified=2025-11-15T19:17:59 | op=+ | size=1342 | tokens=312 | type=markdown ###
<<< BOF <<<
# Examples

Pyvider.cty includes a comprehensive set of runnable examples that demonstrate all features.

## Running Examples

All examples are located in the `examples/` directory of the repository. You can run any example directly:

```bash
python examples/getting-started/quick-start.py
python examples/types/primitives.py
python examples/advanced/marks.py
```

Or run all examples at once:

```bash
python examples/run_all_examples.py
```

## Example Categories

### Getting Started

- **quick-start.py** - The 5-minute quick start example

### Type Examples

- **primitives.py** - String, Number, and Bool types
- **collections.py** - List, Map, and Set types
- **structural.py** - Object and Tuple types
- **dynamic.py** - Dynamic type usage
- **capsule.py** - Capsule types for opaque data

### Advanced Examples

- **marks.py** - Attaching metadata to values
- **functions.py** - Using built-in functions
- **serialization.py** - MessagePack serialization
- **path-navigation.py** - Navigating nested structures
- **terraform-interop.py** - Working with Terraform types

## Next Steps

After exploring the examples, check out:

- **[User Guide](../user-guide/index.md)** - Comprehensive documentation
- **[How-To Guides](../how-to/index.md)** - Task-oriented guides
- **[API Reference](../api/index.md)** - Complete API documentation
>>> EOF >>>

### FILE 18: getting-started/first-type-system.md | checksum=89d22bffdde0... | modified=2025-11-15T19:17:59 | op=+ | size=4820 | tokens=1197 | type=markdown ###
<<< BOF <<<
# Your First Type System

Now that you've seen the basics, let's dive deeper into understanding how pyvider.cty's type system works.

## Core Concepts

Before building more complex types, let's understand the main components:

### Types

A **Type** defines the shape and constraints of your data. Types in pyvider.cty include:

- **Primitives**: `CtyString`, `CtyNumber`, `CtyBool`
- **Collections**: `CtyList`, `CtyMap`, `CtySet`
- **Structural**: `CtyObject`, `CtyTuple`
- **Special**: `CtyDynamic` (runtime type determination)

### Values

A **Value** is an instance of a type. Values are:

- **Immutable** - Once created, they cannot be changed
- **Type-safe** - They always conform to their type schema
- **Rich** - They carry metadata like marks and null status

### Validation

**Validation** is the process of checking if raw Python data conforms to a type. If valid, you get a `CtyValue`. If not, you get a clear error.

### Conversion

**Conversion** transforms between cty values and raw Python values, or between different cty types.

## Building a More Complex Type

Let's build a type for a blog post system:

```python
from pyvider.cty import (
    CtyObject, CtyString, CtyNumber, CtyList, CtyBool
)

# Define a comment type
comment_type = CtyObject(
    attribute_types={
        "author": CtyString(),
        "text": CtyString(),
        "likes": CtyNumber()
    }
)

# Define a blog post type
post_type = CtyObject(
    attribute_types={
        "title": CtyString(),
        "content": CtyString(),
        "author": CtyString(),
        "published": CtyBool(),
        "comments": CtyList(element_type=comment_type),
        "tags": CtyList(element_type=CtyString())
    }
)
```

Notice how we can nest types - the `comments` field is a list of `comment_type` objects.

## Validating Complex Data

Now let's validate some data:

```python
post_data = {
    "title": "Getting Started with Pyvider CTY",
    "content": "This is a great library for type-safe data...",
    "author": "Alice",
    "published": True,
    "comments": [
        {
            "author": "Bob",
            "text": "Great post!",
            "likes": 5
        },
        {
            "author": "Charlie",
            "text": "Very helpful, thanks!",
            "likes": 3
        }
    ],
    "tags": ["python", "types", "tutorial"]
}

try:
    post_value = post_type.validate(post_data)
    print("‚úÖ Post validated successfully!")
except Exception as e:
    print(f"‚ùå Validation failed: {e}")
```

## Optional Attributes

Sometimes you want fields to be optional:

```python
user_type = CtyObject(
    attribute_types={
        "name": CtyString(),
        "email": CtyString(),
        "age": CtyNumber(),
        "bio": CtyString()
    },
    optional_attributes={"age", "bio"}
)

# This is valid - age and bio are optional
user_data = {
    "name": "Alice",
    "email": "alice@example.com"
}

user_value = user_type.validate(user_data)

# Optional attributes that weren't provided are null
print(f"Age is null: {user_value['age'].is_null}")  # True
print(f"Bio is null: {user_value['bio'].is_null}")  # True
```

## Accessing Nested Data

With nested structures, you can chain access:

```python
post_value = post_type.validate(post_data)

# Access nested data
first_comment = post_value['comments'][0]
print(f"First comment by: {first_comment['author'].raw_value}")
print(f"Comment text: {first_comment['text'].raw_value}")

# Iterate over comments
for i, comment in enumerate(post_value['comments']):
    author = comment['author'].raw_value
    text = comment['text'].raw_value
    likes = comment['likes'].raw_value
    print(f"Comment {i+1} by {author}: {text} ({likes} likes)")
```

## What About Invalid Data?

pyvider.cty provides clear error messages when validation fails:

```python
invalid_data = {
    "title": "My Post",
    "content": "Content here",
    "author": "Alice",
    "published": "yes",  # Should be boolean!
    "comments": [],
    "tags": []
}

try:
    post_value = post_type.validate(invalid_data)
except Exception as e:
    print(f"Error: {e}")
    # Output: Error: Attribute 'published': expected CtyBool, got str
```

## Next Steps

Now you understand the fundamentals! Continue learning:

- **[Explore Examples](examples.md)** - See more practical examples
- **[User Guide: Core Concepts](../user-guide/core-concepts/types.md)** - Deep dive into types
- **[User Guide: Type Reference](../user-guide/type-reference/primitives.md)** - Learn about all available types

---

**Key Concepts:**

- Types define data structure, values hold the actual data
- Values are immutable and type-safe
- Validation converts raw Python data to cty values
- Optional attributes can be marked when defining objects
- Nested structures are fully supported
- Error messages are clear and actionable
>>> EOF >>>

### FILE 19: getting-started/index.md | checksum=bda881543aad... | modified=2025-11-15T19:17:59 | op=+ | size=1480 | tokens=340 | type=markdown ###
<<< BOF <<<
# Getting Started with Pyvider CTY

Welcome to pyvider.cty! This section will help you get up and running quickly.

## Learning Path

Follow these guides in order to get started with pyvider.cty:

1. **[Installation](installation.md)** - Install pyvider.cty in your project
2. **[Quick Start (5 minutes)](quick-start.md)** - Build your first type-safe data structure
3. **[Your First Type System](first-type-system.md)** - Understand the fundamentals
4. **[Examples](examples.md)** - Explore runnable examples

## What You'll Learn

By the end of this section, you'll understand:

- How to install and set up pyvider.cty
- The basic concepts of types and values
- How to validate data against type schemas
- How to access and manipulate cty values
- How to serialize and deserialize data

## Prerequisites

- **Python 3.11 or higher** - pyvider.cty uses modern Python features
- **Basic Python knowledge** - Understanding of classes, dictionaries, and lists
- **Optional**: Familiarity with HashiCorp's Terraform (for Terraform integration features)

## Next Steps

After completing the getting started guides, you can:

- Explore the **[User Guide](../user-guide/index.md)** for comprehensive coverage of all features
- Check out the **[How-To Guides](../how-to/index.md)** for practical solutions to common tasks
- Reference the **[API Documentation](../api/index.md)** for detailed API information

---

Ready to get started? Begin with **[Installation](installation.md)** ‚Üí
>>> EOF >>>

### FILE 20: getting-started/installation.md | checksum=17fb14a57bfa... | modified=2025-11-15T19:17:59 | op=+ | size=1717 | tokens=407 | type=markdown ###
<<< BOF <<<
# Installation

This guide will help you install pyvider.cty in your Python project.

## Requirements

- **Python 3.11 or higher** - pyvider.cty uses modern Python type hints and features
- **pip or uv** - Package installer for Python

You can check your Python version with:

```bash
python --version
```

## Installation Methods

### Using uv (Recommended)

[uv](https://github.com/astral-sh/uv) is a fast Python package installer and resolver.

```bash
uv add pyvider-cty
```

This will:
- Add pyvider-cty to your project dependencies
- Install the package and its dependencies
- Update your project's lock file

### Using pip

If you're using pip, you can install pyvider.cty with:

```bash
pip install pyvider-cty
```

### Development Installation

If you want to contribute to pyvider.cty or work with the latest development version:

```bash
# Clone the repository
git clone https://github.com/provide-io/pyvider-cty.git
cd pyvider-cty

# Install in development mode with uv
uv sync

# Or with pip
pip install -e ".[dev]"
```

## Verify Installation

After installation, verify that pyvider.cty is installed correctly:

```python
import pyvider.cty
print(pyvider.cty.__version__)
```

You should see the version number printed without any errors.

## Dependencies

pyvider.cty has minimal dependencies:

- **attrs** - For clean class definitions
- **msgpack** - For MessagePack serialization (go-cty compatibility)
- **provide-foundation** - Foundation utilities and error handling

These will be installed automatically when you install pyvider.cty.

## Next Steps

Now that you have pyvider.cty installed, continue to the **[Quick Start](quick-start.md)** guide to build your first type-safe data structure.
>>> EOF >>>

### FILE 21: getting-started/quick-start.md | checksum=c7b02628b142... | modified=2025-11-15T19:17:59 | op=+ | size=4272 | tokens=1093 | type=markdown ###
<<< BOF <<<
# Quick Start (5 Minutes)

This quick start guide will have you working with pyvider.cty in just 5 minutes. You'll learn the fundamental pattern: **Define ‚Üí Validate ‚Üí Access ‚Üí Serialize**.

## Your First Type-Safe Data Structure

Let's build a simple user profile system with type validation.

### 1. Import Required Types

```python
from pyvider.cty import CtyString, CtyNumber, CtyBool, CtyList, CtyObject
from pyvider.cty.codec import cty_to_msgpack, cty_from_msgpack
```

### 2. Define a Type Schema

Define what a valid user profile looks like:

```python
person_type = CtyObject(
    attribute_types={
        "name": CtyString(),
        "age": CtyNumber(),
        "active": CtyBool(),
        "tags": CtyList(element_type=CtyString()),
    }
)
```

This schema says: "A person must have a name (string), age (number), active status (boolean), and a list of tags (strings)."

### 3. Validate Data

Now validate some raw Python data against this schema:

```python
# Create a raw Python dictionary
user_data = {
    "name": "Alice",
    "age": 30,
    "active": True,
    "tags": ["developer", "python"]
}

# Validate the data
try:
    person_value = person_type.validate(user_data)
    print("‚úÖ Validation successful!")
except Exception as e:
    print(f"‚ùå Validation failed: {e}")
```

If the data doesn't match the schema, you'll get a clear error message explaining what's wrong.

### 4. Access Data

Once validated, you have an immutable `CtyValue` with type-safe access:

```python
# Access attributes (returns CtyValue objects)
print(f"Name: {person_value['name'].raw_value}")  # Output: Alice
print(f"Age: {person_value['age'].raw_value}")    # Output: 30

# Iterate over the list
print("Tags:")
for tag_value in person_value['tags']:
    print(f"  - {tag_value.raw_value}")
```

**Key Point**: When you access attributes or elements, you get back `CtyValue` objects. Use `.raw_value` to get the underlying Python value.

### 5. Serialize to MessagePack

Serialize the value for storage or transmission:

```python
# Serialize to MessagePack binary format
msgpack_bytes = cty_to_msgpack(person_value, person_type)
print(f"\nSerialized to {len(msgpack_bytes)} bytes")
```

MessagePack is a binary format that's compact and compatible with go-cty for cross-language interoperability.

### 6. Deserialize from MessagePack

Reconstruct the value from MessagePack:

```python
# Deserialize from MessagePack
reconstructed_value = cty_from_msgpack(msgpack_bytes, person_type)
assert reconstructed_value['name'].raw_value == "Alice"
print("‚úÖ Successfully reconstructed value!")
```

## Complete Example

Here's the complete working example:

```python
from pyvider.cty import CtyString, CtyNumber, CtyBool, CtyList, CtyObject
from pyvider.cty.codec import cty_to_msgpack, cty_from_msgpack

# 1. Define schema
person_type = CtyObject(
    attribute_types={
        "name": CtyString(),
        "age": CtyNumber(),
        "active": CtyBool(),
        "tags": CtyList(element_type=CtyString()),
    }
)

# 2. Validate data
user_data = {
    "name": "Alice",
    "age": 30,
    "active": True,
    "tags": ["developer", "python"]
}

person_value = person_type.validate(user_data)

# 3. Access data
print(f"Name: {person_value['name'].raw_value}")

# 4. Serialize
msgpack_bytes = cty_to_msgpack(person_value, person_type)

# 5. Deserialize
reconstructed = cty_from_msgpack(msgpack_bytes, person_type)
assert reconstructed['name'].raw_value == "Alice"
print("‚úÖ All done!")
```

## Try It Yourself

You can run this example from the repository:

```bash
python examples/getting-started/quick-start.py
```

## What's Next?

You've learned the core workflow! Now you can:

- **[Learn more about types and values](first-type-system.md)** - Understand the fundamentals
- **[Explore more examples](examples.md)** - See pyvider.cty in action
- **[Dive into the User Guide](../user-guide/index.md)** - Learn about all features

---

**Key Takeaways:**

- Define schemas with `CtyType` objects (like `CtyString()`, `CtyObject()`)
- Validate data with `.validate()` - returns immutable `CtyValue`
- Access data with `[]` notation - returns `CtyValue`, use `.raw_value` for Python values
- Serialize with `cty_to_msgpack()` and deserialize with `cty_from_msgpack()`
>>> EOF >>>

### FILE 22: how-to/create-custom-types.md | checksum=0cc89e3fa500... | modified=2025-11-15T19:17:59 | op=+ | size=9429 | tokens=2153 | type=markdown ###
<<< BOF <<<
# How to Create Custom Types

This guide shows advanced techniques for creating custom types and extending pyvider.cty's type system.

## When to Create Custom Types

Consider custom types when you need:
- Domain-specific validation logic
- Reusable type compositions
- Complex validation rules
- Custom serialization behavior

## Type Composition

The simplest way to create "custom" types is through composition:

```python
from pyvider.cty import CtyObject, CtyString, CtyNumber, CtyBool, CtyList

# Create reusable composite types
def EmailType():
    """String type for email addresses."""
    return CtyString()  # In practice, add validation

def URLType():
    """String type for URLs."""
    return CtyString()

def PositiveNumberType():
    """Number type for positive values."""
    return CtyNumber()  # In practice, add validation

# Use them in schemas
user_type = CtyObject(
    attribute_types={
        "name": CtyString(),
        "email": EmailType(),
        "website": URLType(),
        "age": PositiveNumberType()
    }
)
```

## Factory Functions

Create factory functions for common type patterns:

```python
def TimestampType():
    """ISO 8601 timestamp as string."""
    return CtyString()

def IDType():
    """Unique identifier as string."""
    return CtyString()

def EnumType(*allowed_values):
    """Constrained string enum."""
    # Note: Real implementation would validate against allowed_values
    return CtyString()

# Usage
resource_type = CtyObject(
    attribute_types={
        "id": IDType(),
        "status": EnumType("active", "inactive", "pending"),
        "created_at": TimestampType()
    }
)
```

## Validation Wrappers

Wrap types with additional validation:

```python
from pyvider.cty import CtyString, CtyNumber
from pyvider.cty.exceptions import CtyValidationError
import re

class EmailString:
    """Email validated string type."""

    def __init__(self):
        self.base_type = CtyString()

    def validate(self, value):
        # First validate as string
        cty_value = self.base_type.validate(value)

        # Then check email format
        email_pattern = r'^[\w\.-]+@[\w\.-]+\.\w+$'
        if not re.match(email_pattern, cty_value.raw_value):
            raise CtyValidationError(f"Invalid email format: {value}")

        return cty_value

# Usage
email_type = EmailString()
valid_email = email_type.validate("user@example.com")
```

## Range-Constrained Numbers

```python
class RangeNumber:
    """Number type with min/max constraints."""

    def __init__(self, min_value=None, max_value=None):
        self.base_type = CtyNumber()
        self.min_value = min_value
        self.max_value = max_value

    def validate(self, value):
        cty_value = self.base_type.validate(value)
        num = float(cty_value.raw_value)

        if self.min_value is not None and num < self.min_value:
            raise CtyValidationError(
                f"Value {num} is less than minimum {self.min_value}"
            )

        if self.max_value is not None and num > self.max_value:
            raise CtyValidationError(
                f"Value {num} is greater than maximum {self.max_value}"
            )

        return cty_value

# Usage
age_type = RangeNumber(min_value=0, max_value=150)
port_type = RangeNumber(min_value=1, max_value=65535)

person = CtyObject(
    attribute_types={
        "name": CtyString(),
        "age": age_type
    }
)
```

## Pattern-Validated Strings

```python
class PatternString:
    """String type with regex pattern validation."""

    def __init__(self, pattern, error_message=None):
        self.base_type = CtyString()
        self.pattern = re.compile(pattern)
        self.error_message = error_message or f"Must match pattern: {pattern}"

    def validate(self, value):
        cty_value = self.base_type.validate(value)

        if not self.pattern.match(cty_value.raw_value):
            raise CtyValidationError(self.error_message)

        return cty_value

# Usage
phone_type = PatternString(
    r'^\+?1?\d{10,14}$',
    "Must be a valid phone number"
)

zip_code_type = PatternString(
    r'^\d{5}(-\d{4})?$',
    "Must be a valid US ZIP code"
)

contact = CtyObject(
    attribute_types={
        "phone": phone_type,
        "zip": zip_code_type
    }
)
```

## Length-Constrained Collections

```python
from pyvider.cty import CtyList

class SizedList:
    """List type with size constraints."""

    def __init__(self, element_type, min_length=None, max_length=None):
        self.base_type = CtyList(element_type=element_type)
        self.min_length = min_length
        self.max_length = max_length

    def validate(self, value):
        cty_value = self.base_type.validate(value)

        length = len(value)

        if self.min_length is not None and length < self.min_length:
            raise CtyValidationError(
                f"List length {length} is less than minimum {self.min_length}"
            )

        if self.max_length is not None and length > self.max_length:
            raise CtyValidationError(
                f"List length {length} is greater than maximum {self.max_length}"
            )

        return cty_value

# Usage
tags_type = SizedList(CtyString(), min_length=1, max_length=10)
```

## Conditional Validation

```python
class ConditionalObject:
    """Object type with conditional field requirements."""

    def __init__(self, base_schema, conditionals):
        self.base_schema = base_schema
        self.conditionals = conditionals

    def validate(self, value):
        # First validate against base schema
        cty_value = self.base_schema.validate(value)

        # Then check conditional rules
        for condition, required_fields in self.conditionals:
            if condition(value):
                for field in required_fields:
                    if field not in value or value[field] is None:
                        raise CtyValidationError(
                            f"Field '{field}' is required when condition is met"
                        )

        return cty_value

# Usage
payment_schema = CtyObject(
    attribute_types={
        "method": CtyString(),
        "credit_card": CtyString(),
        "bank_account": CtyString()
    },
    optional_attributes={"credit_card", "bank_account"}
)

conditionals = [
    (lambda v: v["method"] == "card", ["credit_card"]),
    (lambda v: v["method"] == "bank", ["bank_account"])
]

payment_type = ConditionalObject(payment_schema, conditionals)
```

## Type Registries

Organize custom types in registries:

```python
class TypeRegistry:
    """Registry for custom types."""

    def __init__(self):
        self.types = {}

    def register(self, name, type_factory):
        """Register a type factory."""
        self.types[name] = type_factory

    def get(self, name):
        """Get a registered type."""
        if name not in self.types:
            raise ValueError(f"Unknown type: {name}")
        return self.types[name]()

    def create_object(self, schema_dict):
        """Create object from schema dictionary."""
        attribute_types = {}
        for attr, type_name in schema_dict.items():
            attribute_types[attr] = self.get(type_name)

        return CtyObject(attribute_types)

# Usage
registry = TypeRegistry()
registry.register("email", EmailString)
registry.register("age", lambda: RangeNumber(0, 150))
registry.register("phone", lambda: PatternString(r'^\+?1?\d{10,14}$'))

# Create types from registry
user_schema = registry.create_object({
    "name": "string",
    "email": "email",
    "age": "age"
})
```

## Best Practices

1. **Compose before creating**: Use existing types when possible
2. **Validate incrementally**: Build on base type validation
3. **Provide clear errors**: Make validation failures informative
4. **Document constraints**: Clearly document what your types enforce
5. **Test thoroughly**: Custom types need comprehensive tests
6. **Consider reusability**: Design for use across your codebase

## Common Patterns

### Domain-Specific Types

```python
# Application-specific types
class UserIDType:
    """User ID with format validation."""
    def __init__(self):
        self.base_type = PatternString(r'^user_[a-f0-9]{16}$')

    def validate(self, value):
        return self.base_type.validate(value)

class ResourceARNType:
    """AWS ARN type."""
    def __init__(self):
        self.base_type = PatternString(r'^arn:aws:[a-z0-9-]+:[a-z0-9-]*:\d+:.+$')

    def validate(self, value):
        return self.base_type.validate(value)
```

### Versioned Schemas

```python
def UserSchemaV1():
    """User schema version 1."""
    return CtyObject(
        attribute_types={
            "name": CtyString(),
            "email": EmailString()
        }
    )

def UserSchemaV2():
    """User schema version 2 with additional fields."""
    return CtyObject(
        attribute_types={
            "name": CtyString(),
            "email": EmailString(),
            "phone": PatternString(r'^\+?1?\d{10,14}$'),
            "created_at": TimestampType()
        }
    )

# Select schema based on version
def get_user_schema(version):
    schemas = {
        1: UserSchemaV1,
        2: UserSchemaV2
    }
    return schemas[version]()
```

## Next Steps

- [Validate complex data](validate-data.md)
- [Work with Terraform types](work-with-terraform.md)
- [Learn about capsule types](../user-guide/type-reference/capsule.md)
>>> EOF >>>

### FILE 23: how-to/index.md | checksum=76876511df67... | modified=2025-11-15T19:17:59 | op=+ | size=1835 | tokens=409 | type=markdown ###
<<< BOF <<<
# How-To Guides

Practical, task-oriented guides for common use cases with pyvider.cty.

## Available Guides

### Data Validation
- **[Validate Complex Data Structures](validate-data.md)** - Comprehensive guide to validating nested structures, collections, and complex data
  - Basic validation patterns
  - Nested structures
  - Optional fields
  - Collections (lists, maps, sets)
  - Error handling and recovery

### Serialization
- **[Serialize and Deserialize Values](serialize-values.md)** - Work with MessagePack format for storage and transmission
  - Basic serialization
  - Complex structures
  - File storage
  - Cross-language compatibility
  - Compression and optimization

### Terraform Integration
- **[Work with Terraform Types](work-with-terraform.md)** - Parse and work with Terraform type systems
  - Parse Terraform type strings
  - Validate Terraform configurations
  - Module input/output handling
  - Provider development patterns

### Advanced Usage
- **[Create Custom Types](create-custom-types.md)** - Extend the type system with custom validation
  - Type composition and factories
  - Validation wrappers
  - Domain-specific types
  - Type registries

- **[Migrate from go-cty](migrate-from-go-cty.md)** - Port Go code to Python
  - API differences
  - Serialization compatibility
  - Common patterns translation
  - Migration checklist

## Contributing

Want to contribute a how-to guide? Check out our [Contributing Guidelines](https://github.com/provide-io/pyvider-cty/blob/main/CONTRIBUTING.md)!

## Other Resources

- **[Getting Started](../getting-started/index.md)** - Learn the basics
- **[User Guide](../user-guide/index.md)** - Comprehensive documentation
- **[API Reference](../api/index.md)** - Complete API documentation
- **[Examples](../getting-started/examples.md)** - Runnable code examples
>>> EOF >>>

### FILE 24: how-to/migrate-from-go-cty.md | checksum=6db3452cd695... | modified=2025-11-15T19:17:59 | op=+ | size=8721 | tokens=2413 | type=markdown ###
<<< BOF <<<
# How to Migrate from go-cty

This guide helps you migrate from HashiCorp's go-cty (Go) to pyvider.cty (Python) with step-by-step instructions and practical examples.

> **Want a detailed feature comparison?** See the **[go-cty Comparison](../reference/go-cty-comparison.md)** reference for comprehensive API differences, feature parity matrix, and performance considerations. This guide focuses on the practical migration process.

## Key Differences

### Language Differences

| Aspect | go-cty (Go) | pyvider.cty (Python) |
|--------|-------------|----------------------|
| **Language** | Go | Python 3.11+ |
| **Type System** | Go interfaces | Python classes with type hints |
| **Null Safety** | Built-in | `is_null` property |
| **Immutability** | By design | By design (attrs frozen) |
| **Error Handling** | `error` return values | Python exceptions |

### API Differences

#### Creating Types

**go-cty (Go):**
```go
import "github.com/zclconf/go-cty/cty"

stringType := cty.String
numberType := cty.Number
boolType := cty.Bool

listType := cty.List(cty.String)
objectType := cty.Object(map[string]cty.Type{
    "name": cty.String,
    "age":  cty.Number,
})
```

**pyvider.cty (Python):**
```python
from pyvider.cty import CtyString, CtyNumber, CtyBool, CtyList, CtyObject

string_type = CtyString()
number_type = CtyNumber()
bool_type = CtyBool()

list_type = CtyList(element_type=CtyString())
object_type = CtyObject(
    attribute_types={
        "name": CtyString(),
        "age": CtyNumber()
    }
)
```

#### Creating Values

**go-cty (Go):**
```go
strVal := cty.StringVal("hello")
numVal := cty.NumberIntVal(42)
boolVal := cty.BoolVal(true)

objVal := cty.ObjectVal(map[string]cty.Value{
    "name": cty.StringVal("Alice"),
    "age":  cty.NumberIntVal(30),
})
```

**pyvider.cty (Python):**
```python
# pyvider.cty validates raw Python data
object_type = CtyObject(
    attribute_types={
        "name": CtyString(),
        "age": CtyNumber()
    }
)

obj_val = object_type.validate({
    "name": "Alice",
    "age": 30
})
```

#### Accessing Values

**go-cty (Go):**
```go
// Type assertion required
name := objVal.GetAttr("name").AsString()
age := objVal.GetAttr("age").AsBigFloat()

// Check if null
if objVal.IsNull() {
    // handle null
}
```

**pyvider.cty (Python):**
```python
# Dictionary-style access
name = obj_val['name'].raw_value  # "Alice"
age = obj_val['age'].raw_value    # 30

# Check if null
if obj_val.is_null:
    # handle null
```

## Serialization

### MessagePack

Both go-cty and pyvider.cty use MessagePack for serialization, and they're compatible!

**go-cty (Go):**
```go
import "github.com/zclconf/go-cty/cty/msgpack"

// Serialize
encoded, err := msgpack.Marshal(val, valType)
if err != nil {
    // handle error
}

// Deserialize
decoded, err := msgpack.Unmarshal(encoded, valType)
if err != nil {
    // handle error
}
```

**pyvider.cty (Python):**
```python
from pyvider.cty.codec import cty_to_msgpack, cty_from_msgpack

# Serialize
encoded = cty_to_msgpack(val, val_type)

# Deserialize
decoded = cty_from_msgpack(encoded, val_type)
```

**Cross-language compatibility:**
```python
# Python can read Go's msgpack
go_encoded = load_from_go_service()
py_value = cty_from_msgpack(go_encoded, schema)

# Go can read Python's msgpack
py_encoded = cty_to_msgpack(py_value, schema)
send_to_go_service(py_encoded)
```

## Type Parsing

### Terraform Type Strings

**go-cty (Go):**
```go
import "github.com/hashicorp/hcl/v2/hclsyntax"

// Parse type string
expr, diags := hclsyntax.ParseExpression([]byte("list(string)"), "", hcl.Pos{})
valType, diags := convert.GetType(expr, nil)
```

**pyvider.cty (Python):**
```python
from pyvider.cty.parser import parse_tf_type_to_ctytype

# Parse type string
val_type = parse_tf_type_to_ctytype("list(string)")
```

## Common Patterns

### Validation

**go-cty (Go):**
```go
// Explicit conversion/validation
val, err := convert.Convert(unknownVal, targetType)
if err != nil {
    // validation failed
}
```

**pyvider.cty (Python):**
```python
# Validation via validate method
try:
    val = target_type.validate(raw_data)
except CtyValidationError as e:
    # validation failed
```

### Iterating Collections

**go-cty (Go):**
```go
// List iteration
for it := listVal.ElementIterator(); it.Next(); {
    _, val := it.Element()
    // process val
}

// Object iteration
for it := objVal.ElementIterator(); it.Next(); {
    key, val := it.Element()
    // process key, val
}
```

**pyvider.cty (Python):**
```python
# List iteration (Pythonic)
for val in list_val:
    # process val

# Object iteration
for key in obj_val.attribute_names():
    val = obj_val[key]
    # process key, val

# Or use raw_value
for key, val in obj_val.raw_value.items():
    # process as Python dict
```

### Marks

**go-cty (Go):**
```go
import "github.com/zclconf/go-cty/cty"

// Add mark
marked := val.Mark("sensitive")

// Check for mark
if val.HasMark("sensitive") {
    // handle sensitive data
}

// Remove mark
unmarked := val.Unmark()
```

**pyvider.cty (Python):**
```python
from pyvider.cty.marks import CtyMark

# Create mark
sensitive_mark = CtyMark("sensitive")

# Add mark
marked = val.with_marks({sensitive_mark})

# Check for mark
if sensitive_mark in val.marks:
    # handle sensitive data

# Remove all marks (returns tuple)
unmarked, removed_marks = val.unmark()
```

## Migration Checklist

### Step 1: Install pyvider.cty

```bash
uv add pyvider-cty
# or
pip install pyvider-cty
```

### Step 2: Update Type Definitions

Replace Go type definitions:

```python
# Before (Go):
# myType := cty.Object(map[string]cty.Type{...})

# After (Python):
from pyvider.cty import CtyObject, CtyString, CtyNumber

my_type = CtyObject(
    attribute_types={
        "field1": CtyString(),
        "field2": CtyNumber()
    }
)
```

### Step 3: Update Value Creation

Replace Go value creation:

```python
# Before (Go):
# val := cty.ObjectVal(map[string]cty.Value{...})

# After (Python):
val = my_type.validate({
    "field1": "value",
    "field2": 42
})
```

### Step 4: Update Value Access

Replace Go value access:

```python
# Before (Go):
# str := val.GetAttr("field1").AsString()

# After (Python):
str_val = val['field1'].raw_value
```

### Step 5: Update Error Handling

Replace Go error handling:

```python
# Before (Go):
# val, err := something()
# if err != nil { return err }

# After (Python):
from pyvider.cty.exceptions import CtyValidationError

try:
    val = something()
except CtyValidationError as e:
    # handle error
```

### Step 6: Test Serialization

Verify MessagePack compatibility:

```python
# Test round-trip
encoded = cty_to_msgpack(val, schema)
decoded = cty_from_msgpack(encoded, schema)
assert decoded == val

# Test with Go-produced data
go_data = load_from_go()
py_value = cty_from_msgpack(go_data, schema)
```

## Common Gotchas

### 1. Value Construction

**Go allows direct value construction:**
```go
val := cty.ObjectVal(...)
```

**Python requires validation:**
```python
val = obj_type.validate(...)
```

### 2. Type vs Value

**In Go, types and values are more distinct:**
```go
valType := val.Type()
```

**In Python, use the property:**
```python
val_type = val.type
```

### 3. Null Handling

**Go uses IsNull():**
```go
if val.IsNull() { ... }
```

**Python uses is_null:**
```python
if val.is_null: ...
```

### 4. Unknown Values

**Both support unknown values, but creation differs:**

```python
# pyvider.cty
from pyvider.cty.values import UnknownValue

unknown_val = UnknownValue(CtyString())
```

## Example Migration

### Go Code

```go
package main

import (
    "github.com/zclconf/go-cty/cty"
    "github.com/zclconf/go-cty/cty/msgpack"
)

func validateUser(data map[string]interface{}) (cty.Value, error) {
    userType := cty.Object(map[string]cty.Type{
        "name": cty.String,
        "age":  cty.Number,
    })

    // Convert to cty value
    val := cty.ObjectVal(map[string]cty.Value{
        "name": cty.StringVal(data["name"].(string)),
        "age":  cty.NumberIntVal(int64(data["age"].(int))),
    })

    return val, nil
}
```

### Python Code

```python
from pyvider.cty import CtyObject, CtyString, CtyNumber
from pyvider.cty.exceptions import CtyValidationError

def validate_user(data):
    user_type = CtyObject(
        attribute_types={
            "name": CtyString(),
            "age": CtyNumber()
        }
    )

    try:
        return user_type.validate(data)
    except CtyValidationError as e:
        raise ValueError(f"Invalid user data: {e}")
```

## Next Steps

- [Validate data](validate-data.md)
- [Serialize values](serialize-values.md)
- [Work with Terraform](work-with-terraform.md)
- [Compare with go-cty](../reference/go-cty-comparison.md)
>>> EOF >>>

### FILE 25: how-to/serialize-values.md | checksum=5a1e28c2c3c6... | modified=2025-11-15T19:17:59 | op=+ | size=9888 | tokens=2311 | type=markdown ###
<<< BOF <<<
# How to Serialize and Deserialize Values

This guide shows you how to serialize pyvider.cty values to MessagePack format for storage or transmission, and how to deserialize them back.

## Why MessagePack?

MessagePack is a binary serialization format that:
- Is more compact than JSON
- Preserves type information precisely
- Is compatible with go-cty for cross-language interoperability
- Handles all cty types including marks and unknown values

## Basic Serialization

```python
from pyvider.cty import CtyObject, CtyString, CtyNumber
from pyvider.cty.codec import cty_to_msgpack, cty_from_msgpack

# 1. Create a type and value
person_type = CtyObject(
    attribute_types={
        "name": CtyString(),
        "age": CtyNumber()
    }
)

person_value = person_type.validate({
    "name": "Alice",
    "age": 30
})

# 2. Serialize to MessagePack bytes
msgpack_bytes = cty_to_msgpack(person_value, person_type)
print(f"Serialized to {len(msgpack_bytes)} bytes")

# 3. Deserialize back to CtyValue
reconstructed = cty_from_msgpack(msgpack_bytes, person_type)

# 4. Verify it matches
assert reconstructed['name'].raw_value == "Alice"
assert reconstructed['age'].raw_value == 30
```

## Serializing Complex Structures

### Nested Objects

```python
from pyvider.cty import CtyObject, CtyString, CtyList

# Complex nested type
company_type = CtyObject(
    attribute_types={
        "name": CtyString(),
        "employees": CtyList(
            element_type=CtyObject(
                attribute_types={
                    "name": CtyString(),
                    "title": CtyString()
                }
            )
        )
    }
)

company_data = {
    "name": "Acme Corp",
    "employees": [
        {"name": "Alice", "title": "Engineer"},
        {"name": "Bob", "title": "Designer"}
    ]
}

company_value = company_type.validate(company_data)

# Serialize and deserialize
msgpack_bytes = cty_to_msgpack(company_value, company_type)
restored = cty_from_msgpack(msgpack_bytes, company_type)

# Access nested data
first_employee = restored['employees'][0]
print(first_employee['name'].raw_value)  # "Alice"
```

### Lists and Collections

```python
from pyvider.cty import CtyList, CtyString, CtyMap, CtyNumber

# List serialization
tags_type = CtyList(element_type=CtyString())
tags_value = tags_type.validate(["python", "types", "cty"])

tags_msgpack = cty_to_msgpack(tags_value, tags_type)
restored_tags = cty_from_msgpack(tags_msgpack, tags_type)

# Map serialization
scores_type = CtyMap(element_type=CtyNumber())
scores_value = scores_type.validate({"alice": 95, "bob": 87})

scores_msgpack = cty_to_msgpack(scores_value, scores_type)
restored_scores = cty_from_msgpack(scores_msgpack, scores_type)
```

## Saving to Files

```python
from pathlib import Path

def save_to_file(value, schema, filepath):
    """Save a cty value to a MessagePack file."""
    msgpack_bytes = cty_to_msgpack(value, schema)
    Path(filepath).write_bytes(msgpack_bytes)

def load_from_file(schema, filepath):
    """Load a cty value from a MessagePack file."""
    msgpack_bytes = Path(filepath).read_bytes()
    return cty_from_msgpack(msgpack_bytes, schema)

# Usage
save_to_file(person_value, person_type, "person.msgpack")
loaded_person = load_from_file(person_type, "person.msgpack")
```

## Handling Null and Unknown Values

pyvider.cty preserves null and unknown values during serialization:

```python
# Object with optional fields
user_type = CtyObject(
    attribute_types={
        "name": CtyString(),
        "email": CtyString(),
        "phone": CtyString()
    },
    optional_attributes={"phone"}
)

# Create value with null field
user_value = user_type.validate({
    "name": "Alice",
    "email": "alice@example.com"
    # phone is omitted, will be null
})

# Serialize and deserialize
msgpack_bytes = cty_to_msgpack(user_value, user_type)
restored = cty_from_msgpack(msgpack_bytes, user_type)

# Null status is preserved
assert restored['phone'].is_null == True
```

## Working with Marks

Marks (metadata) are preserved during serialization:

```python
from pyvider.cty import CtyString
from pyvider.cty.marks import CtyMark

# Create a mark
sensitive_mark = CtyMark("sensitive")

# Create value with mark
password_type = CtyString()
password_value = password_type.validate("secret123")

# Add mark
marked_password = password_value.with_marks({sensitive_mark})

# Serialize preserves marks
msgpack_bytes = cty_to_msgpack(marked_password, password_type)
restored = cty_from_msgpack(msgpack_bytes, password_type)

# Mark is preserved
assert sensitive_mark in restored.marks
```

## Batch Serialization

Serialize multiple values efficiently:

```python
def serialize_batch(values_and_schemas):
    """Serialize multiple values to MessagePack."""
    serialized = []
    for value, schema in values_and_schemas:
        msgpack_bytes = cty_to_msgpack(value, schema)
        serialized.append(msgpack_bytes)
    return serialized

def deserialize_batch(msgpack_list, schema):
    """Deserialize multiple values from MessagePack."""
    values = []
    for msgpack_bytes in msgpack_list:
        value = cty_from_msgpack(msgpack_bytes, schema)
        values.append(value)
    return values

# Usage
values = [
    (person1, person_type),
    (person2, person_type),
    (person3, person_type)
]

serialized_batch = serialize_batch(values)
# ... save, transmit, etc.
restored_batch = deserialize_batch(serialized_batch, person_type)
```

## Cross-Language Interoperability

MessagePack serialization is compatible with go-cty:

```python
# Serialize in Python
python_value = person_type.validate({"name": "Alice", "age": 30})
msgpack_bytes = cty_to_msgpack(python_value, person_type)

# These bytes can be read by go-cty in Go
# And go-cty serialized bytes can be read here
```

### Sending Over Network

```python
import requests

def send_cty_value(value, schema, url):
    """Send a cty value over HTTP."""
    msgpack_bytes = cty_to_msgpack(value, schema)

    response = requests.post(
        url,
        data=msgpack_bytes,
        headers={'Content-Type': 'application/msgpack'}
    )
    return response

def receive_cty_value(response, schema):
    """Receive a cty value from HTTP response."""
    msgpack_bytes = response.content
    return cty_from_msgpack(msgpack_bytes, schema)

# Usage
send_cty_value(person_value, person_type, "https://api.example.com/person")
```

## Error Handling

Handle serialization/deserialization errors:

```python
def safe_serialize(value, schema):
    """Safely serialize with error handling."""
    try:
        return cty_to_msgpack(value, schema)
    except Exception as e:
        print(f"Serialization failed: {e}")
        return None

def safe_deserialize(msgpack_bytes, schema):
    """Safely deserialize with error handling."""
    try:
        return cty_from_msgpack(msgpack_bytes, schema)
    except Exception as e:
        print(f"Deserialization failed: {e}")
        return None
```

## Compression

For large data, combine with compression:

```python
import gzip

def serialize_compressed(value, schema):
    """Serialize and compress."""
    msgpack_bytes = cty_to_msgpack(value, schema)
    return gzip.compress(msgpack_bytes)

def deserialize_compressed(compressed_bytes, schema):
    """Decompress and deserialize."""
    msgpack_bytes = gzip.decompress(compressed_bytes)
    return cty_from_msgpack(msgpack_bytes, schema)

# Usage
compressed = serialize_compressed(large_value, large_schema)
print(f"Compressed to {len(compressed)} bytes")

restored = deserialize_compressed(compressed, large_schema)
```

## Best Practices

1. **Always provide the schema**: Deserialization requires the type schema
2. **Use binary mode for files**: MessagePack is binary, use `'wb'` and `'rb'`
3. **Validate after deserialization**: Extra safety check
4. **Version your schemas**: Include version info if schemas might change
5. **Handle errors gracefully**: Network/disk operations can fail
6. **Test round-trips**: Ensure serialize ‚Üí deserialize ‚Üí serialize is stable

## Common Patterns

### Configuration Storage

```python
from pathlib import Path

class ConfigStore:
    """Store and load configuration with type safety."""

    def __init__(self, config_type, filepath):
        self.config_type = config_type
        self.filepath = Path(filepath)

    def save(self, config_value):
        """Save configuration to file."""
        msgpack_bytes = cty_to_msgpack(config_value, self.config_type)
        self.filepath.write_bytes(msgpack_bytes)

    def load(self):
        """Load configuration from file."""
        if not self.filepath.exists():
            raise FileNotFoundError(f"Config not found: {self.filepath}")

        msgpack_bytes = self.filepath.read_bytes()
        return cty_from_msgpack(msgpack_bytes, self.config_type)

# Usage
config_store = ConfigStore(config_type, "app.config")
config_store.save(config_value)
loaded_config = config_store.load()
```

### Caching

```python
from functools import lru_cache
import hashlib

def cache_key(value, schema):
    """Generate cache key from serialized value."""
    msgpack_bytes = cty_to_msgpack(value, schema)
    return hashlib.sha256(msgpack_bytes).hexdigest()

class CtyCache:
    """Cache cty values."""

    def __init__(self):
        self.cache = {}

    def set(self, key, value, schema):
        """Store value in cache."""
        msgpack_bytes = cty_to_msgpack(value, schema)
        self.cache[key] = msgpack_bytes

    def get(self, key, schema):
        """Retrieve value from cache."""
        if key not in self.cache:
            return None
        msgpack_bytes = self.cache[key]
        return cty_from_msgpack(msgpack_bytes, schema)
```

## Next Steps

- [Validate complex data](validate-data.md)
- [Work with Terraform types](work-with-terraform.md)
- [Learn about path navigation](../user-guide/advanced/path-navigation.md)
>>> EOF >>>

### FILE 26: how-to/validate-data.md | checksum=3e6c9039de56... | modified=2025-11-15T19:17:59 | op=+ | size=7819 | tokens=1953 | type=markdown ###
<<< BOF <<<
# How to Validate Complex Data Structures

This guide shows you how to validate complex, nested data structures with pyvider.cty.

## Basic Validation Pattern

The fundamental pattern for validation is:

1. Define a type schema
2. Call `.validate()` with raw Python data
3. Handle validation errors
4. Work with the validated `CtyValue`

```python
from pyvider.cty import CtyObject, CtyString, CtyNumber

# 1. Define schema
user_type = CtyObject(
    attribute_types={
        "name": CtyString(),
        "age": CtyNumber()
    }
)

# 2. Validate
try:
    user_value = user_type.validate({"name": "Alice", "age": 30})
    # 3. Success - work with the value
    print(f"Valid user: {user_value['name'].raw_value}")
except Exception as e:
    # 3. Handle errors
    print(f"Validation failed: {e}")
```

## Validating Nested Structures

For complex nested data, build your schema from the inside out:

```python
from pyvider.cty import CtyObject, CtyString, CtyNumber, CtyList, CtyBool

# Define nested types
address_type = CtyObject(
    attribute_types={
        "street": CtyString(),
        "city": CtyString(),
        "zip": CtyString()
    }
)

contact_type = CtyObject(
    attribute_types={
        "email": CtyString(),
        "phone": CtyString()
    }
)

# Use nested types in main schema
person_type = CtyObject(
    attribute_types={
        "name": CtyString(),
        "age": CtyNumber(),
        "address": address_type,
        "contact": contact_type,
        "active": CtyBool()
    }
)

# Validate nested data
person_data = {
    "name": "Bob",
    "age": 25,
    "address": {
        "street": "123 Main St",
        "city": "Boston",
        "zip": "02101"
    },
    "contact": {
        "email": "bob@example.com",
        "phone": "555-0100"
    },
    "active": True
}

person_value = person_type.validate(person_data)
```

## Optional Fields

Mark fields as optional when they may be missing:

```python
user_type = CtyObject(
    attribute_types={
        "name": CtyString(),
        "email": CtyString(),
        "phone": CtyString(),
        "bio": CtyString()
    },
    optional_attributes={"phone", "bio"}  # These can be omitted
)

# Valid: missing optional fields
minimal_user = user_type.validate({
    "name": "Alice",
    "email": "alice@example.com"
})

# Optional fields are null
print(minimal_user['phone'].is_null)  # True
print(minimal_user['bio'].is_null)    # True
```

## Validating Collections

### Lists with Consistent Types

```python
from pyvider.cty import CtyList, CtyString

# All elements must be strings
tags_type = CtyList(element_type=CtyString())

tags_value = tags_type.validate(["python", "types", "validation"])

# Access elements
for tag in tags_value:
    print(tag.raw_value)
```

### Lists of Objects

```python
# List of user objects
users_type = CtyList(
    element_type=CtyObject(
        attribute_types={
            "name": CtyString(),
            "email": CtyString()
        }
    )
)

users_data = [
    {"name": "Alice", "email": "alice@example.com"},
    {"name": "Bob", "email": "bob@example.com"}
]

users_value = users_type.validate(users_data)

# Access nested data
for user in users_value:
    print(f"{user['name'].raw_value}: {user['email'].raw_value}")
```

### Maps

```python
from pyvider.cty import CtyMap, CtyNumber

# Map of string keys to number values
scores_type = CtyMap(element_type=CtyNumber())

scores_value = scores_type.validate({
    "alice": 95,
    "bob": 87,
    "charlie": 92
})

# Access map values
print(scores_value["alice"].raw_value)  # 95
```

## Handling Validation Errors

Validation errors provide detailed information about what went wrong:

```python
from pyvider.cty.exceptions import CtyValidationError

try:
    user_value = user_type.validate({
        "name": "Alice",
        "age": "thirty"  # Wrong type!
    })
except CtyValidationError as e:
    print(f"Validation error: {e}")
    # Output: Attribute 'age': expected CtyNumber, got str
```

### Validate Multiple Items

```python
def validate_many(data_list, schema):
    """Validate multiple items and collect errors."""
    results = []
    errors = []

    for i, data in enumerate(data_list):
        try:
            value = schema.validate(data)
            results.append(value)
        except CtyValidationError as e:
            errors.append((i, str(e)))

    return results, errors

# Use it
users_data = [
    {"name": "Alice", "age": 30},
    {"name": "Bob", "age": "invalid"},  # Error
    {"name": "Charlie", "age": 25}
]

valid_users, validation_errors = validate_many(users_data, user_type)

print(f"Valid: {len(valid_users)}, Errors: {len(validation_errors)}")
for index, error in validation_errors:
    print(f"Item {index}: {error}")
```

## Dynamic Validation

Use `CtyDynamic` when you don't know the type ahead of time:

```python
from pyvider.cty import CtyDynamic, CtyObject

flexible_type = CtyObject(
    attribute_types={
        "name": CtyString(),
        "data": CtyDynamic()  # Can be any type
    }
})

# The 'data' field can hold any type
example1 = flexible_type.validate({
    "name": "Example 1",
    "data": "some text"
})

example2 = flexible_type.validate({
    "name": "Example 2",
    "data": {"nested": "object"}
})

example3 = flexible_type.validate({
    "name": "Example 3",
    "data": [1, 2, 3]
})
```

## Validating Against Multiple Schemas

Sometimes you need to try different schemas:

```python
def try_validate(data, schemas):
    """Try validating against multiple schemas."""
    for i, schema in enumerate(schemas):
        try:
            return schema.validate(data)
        except CtyValidationError:
            continue
    raise ValueError("Data doesn't match any schema")

# Define alternative schemas
schema_v1 = CtyObject(
    attribute_types={"name": CtyString(), "value": CtyNumber()}
)
schema_v2 = CtyObject(
    attribute_types={"name": CtyString(), "count": CtyNumber()}
)

schemas = [schema_v1, schema_v2]

# Try validation
data = {"name": "Test", "count": 42}
result = try_validate(data, schemas)  # Matches schema_v2
```

## Best Practices

1. **Build schemas incrementally**: Start with simple types and compose them
2. **Use descriptive variable names**: `user_type`, `address_type` are clear
3. **Validate early**: Validate at system boundaries (API inputs, file loads)
4. **Handle errors gracefully**: Provide clear error messages to users
5. **Reuse schemas**: Define common schemas once and import them
6. **Document optional fields**: Make it clear which fields can be omitted

## Common Patterns

### Configuration Validation

```python
config_type = CtyObject(
    attribute_types={
        "api_key": CtyString(),
        "api_url": CtyString(),
        "timeout": CtyNumber(),
        "retries": CtyNumber(),
        "debug": CtyBool()
    },
    optional_attributes={"timeout", "retries", "debug"}
)

def load_config(config_dict):
    """Load and validate configuration."""
    try:
        return config_type.validate(config_dict)
    except CtyValidationError as e:
        raise ValueError(f"Invalid configuration: {e}")
```

### API Response Validation

```python
api_response_type = CtyObject(
    attribute_types={
        "status": CtyString(),
        "data": CtyDynamic(),
        "error": CtyString()
    },
    optional_attributes={"error"}
)

def validate_api_response(response_data):
    """Validate API response structure."""
    response = api_response_type.validate(response_data)

    if response['status'].raw_value == "error":
        error_msg = response['error'].raw_value
        raise Exception(f"API error: {error_msg}")

    return response['data']
```

## Next Steps

- [Serialize validated data](serialize-values.md)
- [Work with Terraform types](work-with-terraform.md)
- [Learn about custom types](create-custom-types.md)
>>> EOF >>>

### FILE 27: how-to/work-with-terraform.md | checksum=638cb5e78884... | modified=2025-11-15T19:17:59 | op=+ | size=9911 | tokens=2440 | type=markdown ###
<<< BOF <<<
# How to Work with Terraform Types

This guide shows you how to use pyvider.cty with Terraform, including parsing Terraform type strings and working with Terraform data structures.

## Parsing Terraform Type Strings

Terraform uses type strings like `list(string)` or `object({name=string,age=number})`. pyvider.cty can parse these:

```python
from pyvider.cty.parser import parse_tf_type_to_ctytype

# Parse simple types
string_type = parse_tf_type_to_ctytype("string")
number_type = parse_tf_type_to_ctytype("number")
bool_type = parse_tf_type_to_ctytype("bool")

# Parse collection types
list_type = parse_tf_type_to_ctytype("list(string)")
map_type = parse_tf_type_to_ctytype("map(number)")
set_type = parse_tf_type_to_ctytype("set(string)")

# Parse complex object types
object_type = parse_tf_type_to_ctytype(
    "object({name=string,age=number,active=bool})"
)

# Use the parsed type
data = {"name": "Alice", "age": 30, "active": True}
value = object_type.validate(data)
```

## Common Terraform Patterns

### Variable Validation

```python
from pyvider.cty.parser import parse_tf_type_to_ctytype

def validate_terraform_variable(var_type_string, var_value):
    """Validate a Terraform variable against its type."""
    try:
        var_type = parse_tf_type_to_ctytype(var_type_string)
        return var_type.validate(var_value)
    except Exception as e:
        raise ValueError(f"Variable validation failed: {e}")

# Example
vpc_config_type = "object({cidr=string,subnets=list(string)})"
vpc_config_data = {
    "cidr": "10.0.0.0/16",
    "subnets": ["10.0.1.0/24", "10.0.2.0/24"]
}

validated = validate_terraform_variable(vpc_config_type, vpc_config_data)
```

### Resource Schema

```python
# Define a resource schema matching Terraform
resource_schema = parse_tf_type_to_ctytype("""
object({
  name = string,
  instance_type = string,
  ami = string,
  tags = map(string)
})
""")

# Validate resource configuration
resource_config = {
    "name": "web-server",
    "instance_type": "t2.micro",
    "ami": "ami-12345",
    "tags": {
        "Environment": "prod",
        "Owner": "ops-team"
    }
}

resource_value = resource_schema.validate(resource_config)
```

## Working with Terraform Modules

### Module Input Variables

```python
from pyvider.cty.parser import parse_tf_type_to_ctytype

# Parse module variable types
module_vars = {
    "vpc_cidr": parse_tf_type_to_ctytype("string"),
    "availability_zones": parse_tf_type_to_ctytype("list(string)"),
    "enable_nat": parse_tf_type_to_ctytype("bool"),
    "tags": parse_tf_type_to_ctytype("map(string)")
}

# Validate module inputs
module_inputs = {
    "vpc_cidr": "10.0.0.0/16",
    "availability_zones": ["us-east-1a", "us-east-1b"],
    "enable_nat": True,
    "tags": {"Project": "demo"}
}

validated_inputs = {}
for var_name, var_type in module_vars.items():
    validated_inputs[var_name] = var_type.validate(module_inputs[var_name])
```

### Module Outputs

```python
# Define output types
output_schema = parse_tf_type_to_ctytype("""
object({
  vpc_id = string,
  subnet_ids = list(string),
  nat_gateway_id = string
})
""")

# Validate module outputs
module_outputs = {
    "vpc_id": "vpc-12345",
    "subnet_ids": ["subnet-111", "subnet-222"],
    "nat_gateway_id": "nat-99999"
}

validated_outputs = output_schema.validate(module_outputs)
```

## Complex Terraform Types

### Nested Objects

```python
# Parse complex nested structure
nested_type = parse_tf_type_to_ctytype("""
object({
  network = object({
    vpc_id = string,
    subnets = list(object({
      id = string,
      cidr = string,
      az = string
    }))
  }),
  compute = object({
    instance_type = string,
    count = number
  })
})
""")

# Validate nested data
infrastructure = {
    "network": {
        "vpc_id": "vpc-12345",
        "subnets": [
            {"id": "subnet-1", "cidr": "10.0.1.0/24", "az": "us-east-1a"},
            {"id": "subnet-2", "cidr": "10.0.2.0/24", "az": "us-east-1b"}
        ]
    },
    "compute": {
        "instance_type": "t2.micro",
        "count": 3
    }
}

infra_value = nested_type.validate(infrastructure)
```

### Optional Attributes

```python
from pyvider.cty import CtyObject, CtyString, CtyNumber, CtyBool

# Define type with optional fields (Terraform style)
instance_type = CtyObject(
    attribute_types={
        "ami": CtyString(),
        "instance_type": CtyString(),
        "key_name": CtyString(),
        "monitoring": CtyBool(),
        "user_data": CtyString()
    },
    optional_attributes={"key_name", "monitoring", "user_data"}
)

# Valid with only required fields
minimal_instance = instance_type.validate({
    "ami": "ami-12345",
    "instance_type": "t2.micro"
})

# Optional fields are null
assert minimal_instance['key_name'].is_null
```

## Provider Development

### Resource State

```python
from pyvider.cty.codec import cty_to_msgpack, cty_from_msgpack

# Define resource state schema
state_schema = parse_tf_type_to_ctytype("""
object({
  id = string,
  name = string,
  status = string,
  created_at = string
})
""")

# Create and serialize state
state_data = {
    "id": "resource-123",
    "name": "my-resource",
    "status": "active",
    "created_at": "2025-01-24T10:00:00Z"
}

state_value = state_schema.validate(state_data)

# Serialize for Terraform
state_msgpack = cty_to_msgpack(state_value, state_schema)

# Later, deserialize
restored_state = cty_from_msgpack(state_msgpack, state_schema)
```

### Schema Definition

```python
# Define provider schema
provider_schema = {
    "resources": {
        "example_instance": parse_tf_type_to_ctytype("""
            object({
              name = string,
              size = string,
              region = string,
              tags = map(string)
            })
        """),
        "example_network": parse_tf_type_to_ctytype("""
            object({
              cidr = string,
              name = string
            })
        """)
    }
}

def validate_resource(resource_type, config):
    """Validate resource configuration."""
    if resource_type not in provider_schema["resources"]:
        raise ValueError(f"Unknown resource type: {resource_type}")

    schema = provider_schema["resources"][resource_type]
    return schema.validate(config)
```

## Handling Terraform Data

### Reading terraform.tfstate

```python
import json

def load_terraform_state(state_file):
    """Load and validate Terraform state file."""
    with open(state_file) as f:
        state = json.load(f)

    # Extract resources
    resources = []
    for resource in state.get("resources", []):
        # Parse resource schema from type
        resource_type = resource["type"]
        instances = resource.get("instances", [])

        for instance in instances:
            # Validate instance attributes
            attributes = instance.get("attributes", {})
            resources.append({
                "type": resource_type,
                "attributes": attributes
            })

    return resources
```

### Working with HCL

```python
# While pyvider.cty doesn't parse HCL directly,
# you can work with the parsed structures

# After parsing HCL to Python dict (using python-hcl2 or similar):
hcl_data = {
    "resource": {
        "aws_instance": {
            "web": {
                "ami": "ami-12345",
                "instance_type": "t2.micro",
                "tags": {"Name": "web-server"}
            }
        }
    }
}

# Extract and validate resource config
resource_config = hcl_data["resource"]["aws_instance"]["web"]
instance_schema = parse_tf_type_to_ctytype("""
    object({
      ami = string,
      instance_type = string,
      tags = map(string)
    })
""")

validated = instance_schema.validate(resource_config)
```

## Best Practices

1. **Parse type strings once**: Cache parsed type schemas
2. **Validate early**: Check types before Terraform execution
3. **Use MessagePack**: For Terraform provider communication
4. **Handle optional fields**: Many Terraform attributes are optional
5. **Test with real data**: Use actual Terraform configs for testing
6. **Document schemas**: Keep schema documentation up to date

## Common Patterns

### Configuration Validator

```python
class TerraformConfigValidator:
    """Validate Terraform configurations."""

    def __init__(self):
        self.schemas = {}

    def register_schema(self, name, type_string):
        """Register a schema for validation."""
        self.schemas[name] = parse_tf_type_to_ctytype(type_string)

    def validate(self, schema_name, data):
        """Validate data against a registered schema."""
        if schema_name not in self.schemas:
            raise ValueError(f"Unknown schema: {schema_name}")

        schema = self.schemas[schema_name]
        return schema.validate(data)

# Usage
validator = TerraformConfigValidator()
validator.register_schema("vpc", "object({cidr=string,name=string})")
validator.register_schema("subnet", "object({cidr=string,vpc_id=string})")

vpc_config = validator.validate("vpc", {
    "cidr": "10.0.0.0/16",
    "name": "main-vpc"
})
```

### Type Introspection

```python
def describe_terraform_type(type_string):
    """Describe a Terraform type in detail."""
    cty_type = parse_tf_type_to_ctytype(type_string)

    # Get type information
    info = {
        "type_name": type(cty_type).__name__,
        "is_collection": hasattr(cty_type, 'element_type'),
        "is_structural": hasattr(cty_type, 'attribute_types')
    }

    if info["is_structural"]:
        info["attributes"] = list(cty_type.attribute_types.keys())

    return info

# Usage
type_info = describe_terraform_type("object({name=string,count=number})")
print(type_info)
```

## Next Steps

- [Validate complex data](validate-data.md)
- [Serialize values](serialize-values.md)
- [Learn about advanced features](../user-guide/advanced/terraform-interop.md)
- [Migrate from go-cty](migrate-from-go-cty.md)
>>> EOF >>>

### FILE 28: index.md | checksum=e78134c4fa1f... | modified=2025-11-15T19:17:59 | op=+ | size=3913 | tokens=938 | type=markdown ###
<<< BOF <<<
# Welcome to Pyvider CTY

**A powerful and flexible type system for Python, compatible with HashiCorp's go-cty.**

`pyvider.cty` is a pure-Python implementation of the [go-cty](https://github.com/zclconf/go-cty) type system, providing strong type validation and serialization capabilities for configuration data. It's designed to work seamlessly with Terraform providers and other HashiCorp ecosystem tools.

---

## Why Pyvider CTY?

### ‚ö° **Expressive and Flexible**
- **Rich Type System**: A comprehensive set of primitive, collection, and structural types to model your data accurately.
- **Dynamic Types**: Handle data with unknown or varying structures using the dynamic type.
- **Capsule Types**: Encapsulate and protect foreign data types within the `cty` system.

### üõ†Ô∏è **Developer Experience**
- **Modern Python**: Leverages Python 3.11+ features with complete type annotations.
- **Clear and Concise API**: A simple and intuitive API for defining types, validating data, and working with values.
- **Detailed Diagnostics**: Get detailed error messages and validation diagnostics to quickly identify and fix issues.

### üèóÔ∏è **Robust and Reliable**
- **Immutable Values**: `cty` values are immutable, ensuring data integrity and preventing unintended side effects.
- **Thoroughly Tested**: A comprehensive test suite ensures the library is reliable and production-ready.
- **Battle-Tested Concepts**: Based on the well-established `cty` type system from HashiCorp's Terraform.

### üîÑ **Cross-Language Compatibility**
- **Go-Cty Interoperability**: Serialize and deserialize data in MessagePack format compatible with go-cty.
- **Terraform Integration**: Parse Terraform type strings and work with Terraform data structures.

---

## Quick Example

```python
from pyvider.cty import CtyObject, CtyString, CtyNumber, CtyList

# Define a type schema
user_type = CtyObject(
    attribute_types={
        "name": CtyString(),
        "age": CtyNumber(),
        "hobbies": CtyList(element_type=CtyString())
    },
    optional_attributes={"age"}
)

# Validate data
user_data = {
    "name": "Alice",
    "hobbies": ["reading", "hiking"]
}

user_val = user_type.validate(user_data)
print(f"Name: {user_val['name'].raw_value}")
```

---

## Where to Start

<div class="grid cards" markdown>

-   :material-rocket-launch-outline: **[Getting Started](getting-started/index.md)**

    ---

    Install pyvider.cty and learn the basics in 5 minutes

-   :material-book-open-variant: **[User Guide](user-guide/index.md)**

    ---

    Comprehensive guide to types, values, and advanced features

-   :material-wrench: **[How-To Guides](how-to/index.md)**

    ---

    Practical guides for common tasks and use cases

-   :material-api: **[API Reference](api/index.md)**

    ---

    Complete API documentation for all types and functions

</div>

---

## Installation

```bash
# With uv (recommended)
uv add pyvider-cty

# With pip
pip install pyvider-cty
```

---

## Features at a Glance

- üéØ **Complete Type System**: Primitives, collections, and structural types
- üîÑ **Cross-Language Compatibility**: Interoperates with go-cty via MessagePack
- üõ°Ô∏è **Type Safety**: Strong validation at value creation
- üè∑Ô∏è **Marks System**: Attach metadata without modifying values
- üó∫Ô∏è **Path Navigation**: Type-safe access to nested data
- ‚ö° **Full Standard Library**: Comprehensive suite of functions for data manipulation

---

## Community and Support

- **GitHub**: [provide-io/pyvider-cty](https://github.com/provide-io/pyvider-cty)
- **Issues**: [Report bugs or request features](https://github.com/provide-io/pyvider-cty/issues)
- **Contributing**: See our [Contributing Guidelines](https://github.com/provide-io/pyvider-cty/blob/main/CONTRIBUTING.md)

---

## License

Apache License 2.0. See [LICENSE](https://github.com/provide-io/pyvider-cty/blob/main/LICENSE) for details.
>>> EOF >>>

### FILE 29: reference/configuration.md | checksum=b54f4ac5f49e... | modified=2025-11-15T19:17:59 | op=+ | size=4698 | tokens=1000 | type=markdown ###
<<< BOF <<<
# Configuration

`pyvider.cty` provides configuration options to customize behavior for different use cases and environments.

## Configuration System

The library uses a configuration system based on environment variables, with sensible defaults for all settings. Configuration is handled through the `CtyConfig` class.

### Accessing Configuration

```python
from pyvider.cty.config.runtime import CtyConfig

# Get current configuration from environment
config = CtyConfig.get_current()

print(f"Type inference cache enabled: {config.enable_type_inference_cache}")
```

## Available Configuration Options

### Type Inference Cache

**Environment Variable**: `PYVIDER_CTY_ENABLE_TYPE_INFERENCE_CACHE`
**Default**: `True`
**Type**: Boolean

Controls whether the type inference cache is enabled for performance optimization.

```bash
# Disable type inference caching
export PYVIDER_CTY_ENABLE_TYPE_INFERENCE_CACHE=false
```

**When to disable:**
- During development when you want fresh type inference on every operation
- In testing scenarios where caching might hide bugs
- In memory-constrained environments

**When to enable (default):**
- Production environments for better performance
- Applications with repeated type inference operations
- Normal usage scenarios

## Configuration Constants

The library defines several important constants in `pyvider.cty.config.defaults`. While these are not configurable at runtime, they define the behavior of the library:

### Validation Limits

- **`MAX_VALIDATION_DEPTH`**: `500` - Maximum depth for nested validation (protects against stack overflow)
- **`MAX_OBJECT_REVISITS`**: `100` - Maximum times an object can be revisited during validation
- **`MAX_VALIDATION_TIME_MS`**: `30000` (30 seconds) - Timeout for pathological validation cases

### MessagePack Codec Settings

- **`MSGPACK_EXT_TYPE_CTY`**: `0` - Extension type code for cty values in MessagePack
- **`MSGPACK_EXT_TYPE_REFINED_UNKNOWN`**: `12` - Extension type code for refined unknowns
- **`MSGPACK_USE_BIN_TYPE_TRUE`**: `True` - Use binary type in MessagePack encoding

## Examples

### Custom Configuration in Tests

```python
import os
from pyvider.cty.config.runtime import CtyConfig

# Disable caching for testing
os.environ["PYVIDER_CTY_ENABLE_TYPE_INFERENCE_CACHE"] = "false"

# Get configuration
config = CtyConfig.get_current()
assert config.enable_type_inference_cache is False
```

### Production Configuration

```bash
# .env file or deployment configuration
PYVIDER_CTY_ENABLE_TYPE_INFERENCE_CACHE=true
```

## Validation Depth Management

While `MAX_VALIDATION_DEPTH` is not runtime-configurable, you can work with deeply nested structures by understanding the limits:

```python
from pyvider.cty.context import get_validation_depth, MAX_VALIDATION_DEPTH

# Check current validation depth (during validation)
current_depth = get_validation_depth()
print(f"Current depth: {current_depth}/{MAX_VALIDATION_DEPTH}")
```

If you encounter depth limit errors, consider:
1. Restructuring your data to be less deeply nested
2. Breaking validation into smaller chunks
3. Using dynamic types for extremely nested structures

## Default Values Reference

All configuration defaults are centralized in `pyvider.cty.config.defaults`:

| Constant | Default | Purpose |
|----------|---------|---------|
| `MAX_VALIDATION_DEPTH` | 500 | Recursion depth limit for validation |
| `MAX_OBJECT_REVISITS` | 100 | Circular reference detection limit |
| `MAX_VALIDATION_TIME_MS` | 30000 | Validation timeout (milliseconds) |
| `ENABLE_TYPE_INFERENCE_CACHE` | True | Type inference caching |

## Advanced: Using Configuration in Custom Types

If you're implementing custom types or validators, you can access configuration:

```python
from pyvider.cty.config.runtime import CtyConfig
from pyvider.cty.config.defaults import MAX_VALIDATION_DEPTH

class MyCustomValidator:
    def __init__(self):
        # Access runtime config
        self.config = CtyConfig.get_current()

        # Access constants
        self.max_depth = MAX_VALIDATION_DEPTH

    def validate(self, data):
        if self.config.enable_type_inference_cache:
            # Use cached inference
            pass
        else:
            # Fresh inference
            pass
```

## Environment Variable Prefix

All pyvider.cty environment variables use the prefix `PYVIDER_CTY_`.

**Example variables:**
- `PYVIDER_CTY_ENABLE_TYPE_INFERENCE_CACHE`

## Related Documentation

- **[Validation](../user-guide/core-concepts/validation.md)** - Understanding validation depth limits
- **[Context](../api/context.md)** - Validation depth tracking
- **[Troubleshooting](troubleshooting.md)** - Handling configuration-related issues
>>> EOF >>>

### FILE 30: reference/glossary.md | checksum=0c74bfeca3d8... | modified=2025-10-24T15:47:32 | op=+ | size=3658 | tokens=828 | type=markdown ###
<<< BOF <<<
# Glossary

This glossary defines key terms and concepts used throughout the `pyvider.cty` documentation.

## Core Concepts

*   **Type**: A `pyvider.cty` type defines the shape and constraints of your data. Types act as schemas against which raw Python data is validated.
*   **Value**: A `pyvider.cty` value is an instance of a `cty` type. It holds the actual data and is immutable. Represented by the `CtyValue` class.
*   **Validation**: The process of checking if a raw Python value conforms to a given `cty` type. Validation returns a `CtyValue` if successful or raises a `CtyValidationError` if the data doesn't match the schema.
*   **Conversion**: The process of transforming values between different `cty` types or between `cty` values and raw Python values. More flexible than validation.

## Type Categories

*   **Primitive Type**: A basic building block of the type system, such as `CtyString`, `CtyNumber`, or `CtyBool`. Represents single, atomic values.
*   **Collection Type**: A type that represents a homogeneous collection of other types, such as `CtyList`, `CtySet`, or `CtyMap`. All elements in a collection must be of the same type.
*   **Structural Type**: A type that represents more complex, structured data with heterogeneous elements, such as `CtyObject` or `CtyTuple`. Different positions or attributes can have different types.
*   **Dynamic Type**: A special type (`CtyDynamic`) that can represent any type of value, with the actual type determined at runtime.
*   **Capsule**: A special type that allows you to encapsulate and protect foreign data types within the `cty` system. Useful for wrapping non-cty objects like file handles or database connections.

## Special Values

*   **Null**: A special value that represents the explicit absence of a value. Created with `CtyValue.null(type)`. Different from Python's `None`.
*   **Unknown**: A special value that represents a value that is not yet known but will be determined later. Created with `CtyValue.unknown(type)`. Common in Terraform for values computed during apply.

## Advanced Features

*   **Mark**: A piece of metadata that is attached to a `cty` value without modifying the value itself. Represented by the `CtyMark` class. Useful for tracking sensitive data or adding annotations.
*   **Function**: A `pyvider.cty` function is a built-in operation for manipulating `cty` values. All functions operate on and return `CtyValue` instances while maintaining immutability.
*   **Type Unification**: The process of finding the most specific type that can represent all given types. Used by the `unify()` function to determine compatible types.
*   **Path**: A sequence of steps (`CtyPath`) used to navigate through nested data structures. Used for precise error reporting and programmatic traversal.
*   **Recursion Detection**: A mechanism to prevent infinite loops when validating circular or deeply nested data structures. Implemented via the `@with_recursion_detection` decorator.

## Interoperability

*   **go-cty**: The Go implementation of the cty type system by HashiCorp. `pyvider.cty` is designed for compatibility with go-cty.
*   **MessagePack**: A binary serialization format used for cross-language data exchange. `pyvider.cty` uses MessagePack for go-cty compatibility.
*   **Terraform Type String**: A string representation of cty types used by Terraform (e.g., `"list(string)"`, `"object({name=string})"`). Can be parsed using `parse_tf_type_to_ctytype()`.
*   **NFC Normalization**: Unicode normalization form used for string values and object attribute names to ensure consistent comparison and hashing across different Unicode representations.
>>> EOF >>>

### FILE 31: reference/go-cty-comparison.md | checksum=b890ecc77ce9... | modified=2025-11-15T19:17:59 | op=+ | size=11741 | tokens=3127 | type=markdown ###
<<< BOF <<<
# Comparison with Go-Cty

`pyvider.cty` is a Python implementation of the `cty` type system, which was originally developed in Go as `go-cty` for use in HashiCorp's Terraform. While `pyvider.cty` aims to be a faithful implementation of the `cty` specification, there are some differences between the two libraries due to language differences and Python idioms.

> **Looking to migrate from go-cty?** See the **[How-To: Migrate from go-cty](../how-to/migrate-from-go-cty.md)** guide for step-by-step migration instructions and a complete checklist. This document focuses on feature comparison and API differences.

## Overview

Both libraries implement the same conceptual type system with:
- Primitive, collection, and structural types
- Null and unknown value semantics
- Mark system for metadata
- Type conversion and unification
- MessagePack serialization for cross-language compatibility

## Key Differences

| Feature | `go-cty` | `pyvider.cty` | Notes |
|---|---|---|---|
| **Language** | Go (compiled) | Python (interpreted) | Affects performance and idioms |
| **Type System** | Go interfaces & structs | Python classes with `@attrs` | Both provide strong typing |
| **API Style** | Idiomatic Go | Idiomatic Python | Different but equivalent patterns |
| **Performance** | Faster (compiled) | Slower (interpreted) | Python fast enough for typical use |
| **Null Handling** | `cty.NullVal(type)` | `CtyValue.null(type)` | Class method vs function |
| **Package Structure** | Multiple packages | Single `pyvider.cty` package | Python convention |

## API Translation Examples

### Creating Types

**Go (go-cty):**
```go
import "github.com/zclconf/go-cty/cty"

// Primitive type
stringType := cty.String

// Object type
personType := cty.Object(map[string]cty.Type{
    "name": cty.String,
    "age":  cty.Number,
})

// List type
listType := cty.List(cty.String)
```

**Python (pyvider.cty):**
```python
from pyvider.cty import CtyString, CtyNumber, CtyObject, CtyList

# Primitive type
string_type = CtyString()

# Object type
person_type = CtyObject(
    attribute_types={
        "name": CtyString(),
        "age": CtyNumber(),
    }
)

# List type
list_type = CtyList(element_type=CtyString())
```

### Creating Values

**Go:**
```go
// String value
strVal := cty.StringVal("hello")

// Number value
numVal := cty.NumberIntVal(42)

// Object value
person := cty.ObjectVal(map[string]cty.Value{
    "name": cty.StringVal("Alice"),
    "age":  cty.NumberIntVal(30),
})

// Null value
nullVal := cty.NullVal(cty.String)

// Unknown value
unknownVal := cty.UnknownVal(cty.String)
```

**Python:**
```python
from pyvider.cty import CtyString, CtyNumber, CtyObject
from pyvider.cty.values import CtyValue

# Validate data (preferred approach)
str_val = CtyString().validate("hello")
num_val = CtyNumber().validate(42)

# Object value
person_type = CtyObject(
    attribute_types={"name": CtyString(), "age": CtyNumber()}
)
person = person_type.validate({"name": "Alice", "age": 30})

# Null value
null_val = CtyValue.null(CtyString())

# Unknown value
unknown_val = CtyValue.unknown(CtyString())
```

### Accessing Values

**Go:**
```go
// Access raw value
rawStr := strVal.AsString()
rawNum, _ := numVal.AsBigFloat().Int64()

// Access object attribute
nameVal := person.GetAttr("name")

// Check for null/unknown
if person.IsNull() {
    // handle null
}
```

**Python:**
```python
# Access raw value
raw_str = str_val.raw_value
raw_num = num_val.raw_value

# Access object attribute
name_val = person['name']

# Check for null/unknown
if person.is_null:
    # handle null
```

### Marks

**Go:**
```go
import "github.com/zclconf/go-cty/cty"

// Create marked value
sensitive := "sensitive"
marked := val.Mark(sensitive)

// Check for marks
if marked.HasMark(sensitive) {
    // handle sensitive data
}

// Remove marks
unmarked, marks := marked.Unmark()
```

**Python:**
```python
from pyvider.cty.marks import CtyMark

# Create marked value
sensitive = CtyMark("sensitive")
marked = val.mark(sensitive)  # Single mark
# Or: marked = val.with_marks({sensitive})  # Set of marks

# Check for marks
if sensitive in marked.marks:
    # handle sensitive data

# Remove all marks (returns tuple of unmarked value and marks)
unmarked_val, removed_marks = marked.unmark()
```

### Type Conversion

**Go:**
```go
import "github.com/zclconf/go-cty/cty/convert"

// Convert string to number
numVal, err := convert.Convert(strVal, cty.Number)
if err != nil {
    // handle conversion error
}

// Unify types
unified, _ := convert.UnifyUnsafe([]cty.Type{cty.String, cty.Number})
```

**Python:**
```python
from pyvider.cty import convert, unify, CtyNumber
from pyvider.cty.exceptions import CtyConversionError

# Convert string to number
try:
    num_val = convert(str_val, CtyNumber())
except CtyConversionError as e:
    # handle conversion error
    pass

# Unify types
unified = unify([CtyString(), CtyNumber()])
```

### Serialization

**Go:**
```go
import (
    "github.com/zclconf/go-cty/cty"
    "github.com/zclconf/go-cty/cty/msgpack"
)

// Serialize to MessagePack
bytes, err := msgpack.Marshal(val, valType)

// Deserialize from MessagePack
val, err = msgpack.Unmarshal(bytes, valType)
```

**Python:**
```python
from pyvider.cty.codec import cty_to_msgpack, cty_from_msgpack

# Serialize to MessagePack
msgpack_bytes = cty_to_msgpack(val, val_type)

# Deserialize from MessagePack
val = cty_from_msgpack(msgpack_bytes, val_type)
```

## Idiom Differences

### Error Handling

**Go:** Uses explicit error returns
```go
val, err := someFunction()
if err != nil {
    return err
}
```

**Python:** Uses exceptions
```python
try:
    val = some_function()
except CtyValidationError as e:
    # handle error
    pass
```

### Iteration

**Go:** Range-based for loops
```go
it := listVal.ElementIterator()
for it.Next() {
    _, elemVal := it.Element()
    // process elemVal
}
```

**Python:** Pythonic iteration
```python
for elem_val in list_val:
    # process elem_val
    pass
```

### Optional Attributes

**Go:** Uses `OptionalAttrs` in object definition
```go
objType := cty.ObjectWithOptionalAttrs(
    map[string]cty.Type{
        "name": cty.String,
        "age":  cty.Number,
    },
    []string{"age"}, // optional attributes
)
```

**Python:** Uses `optional_attributes` parameter
```python
obj_type = CtyObject(
    attribute_types={
        "name": CtyString(),
        "age": CtyNumber()
    },
    optional_attributes={"age"}
)
```

## Serialization Compatibility

The MessagePack serialization format is **fully compatible** between go-cty and pyvider.cty:

```python
# Python serializes
python_bytes = cty_to_msgpack(value, schema)

# Go can deserialize the same bytes
# val, err := msgpack.Unmarshal(python_bytes, goSchema)

# And vice versa - Go serializes, Python deserializes
```

This enables true cross-language interoperability for:
- Terraform provider development
- Multi-language systems
- Configuration sharing

## Performance Considerations

**go-cty advantages:**
- Faster execution (compiled vs interpreted)
- Lower memory overhead
- Better for CPU-intensive operations

**pyvider.cty advantages:**
- Rapid development and prototyping
- Rich Python ecosystem integration
- Easier debugging and introspection
- Better for I/O-bound operations

**Performance tips for pyvider.cty:**
```python
# Cache schemas - don't recreate them
config_schema = CtyObject(
    attribute_types={...}
)  # Create once

# Reuse validated values
config = config_schema.validate(raw_data)  # Validate once
for _ in range(1000):
    process(config)  # Reuse many times

# Avoid repeated type construction in loops
# Bad: Creates new type each iteration
for data in large_dataset:
    schema = CtyObject(attribute_types={"field": CtyString()})
    value = schema.validate(data)

# Good: Create schema once
schema = CtyObject(attribute_types={"field": CtyString()})
for data in large_dataset:
    value = schema.validate(data)
```

## Migration Checklist

When migrating from go-cty to pyvider.cty:

- [ ] Replace `cty.StringVal()` with `.validate()` pattern
- [ ] Update `val.AsString()` to `val.raw_value`
- [ ] Change `val.GetAttr("key")` to `val['key']`
- [ ] Replace `cty.NullVal(type)` with `CtyValue.null(type)`
- [ ] Update error handling from `err` returns to exceptions
- [ ] Convert iterator loops to Python `for` loops
- [ ] Update package imports to `pyvider.cty`
- [ ] Review and update optional attribute syntax
- [ ] Test MessagePack serialization compatibility
- [ ] Verify mark handling with new API

## Feature Parity Matrix

| Feature | go-cty | pyvider.cty | Notes |
|---|---|---|---|
| **Primitive Types** | ‚úÖ | ‚úÖ | Full parity |
| **Collection Types** | ‚úÖ | ‚úÖ | Full parity |
| **Structural Types** | ‚úÖ | ‚úÖ | Full parity |
| **Dynamic Type** | ‚úÖ | ‚úÖ | Full parity |
| **Capsule Types** | ‚úÖ | ‚úÖ | Full parity |
| **Marks** | ‚úÖ | ‚úÖ | Full parity |
| **Null/Unknown Values** | ‚úÖ | ‚úÖ | Full parity |
| **Refined Unknowns** | ‚úÖ | ‚úÖ | Full parity |
| **Type Conversion** | ‚úÖ | ‚úÖ | Full parity |
| **Type Unification** | ‚úÖ | ‚úÖ | Full parity |
| **MessagePack Serialization** | ‚úÖ | ‚úÖ | Cross-compatible |
| **JSON Encoding Functions** | ‚úÖ | ‚úÖ | Via `jsonencode`/`jsondecode` functions |
| **Standard Library Functions** | ‚úÖ | ‚úÖ | Comparable coverage |
| **Path Navigation** | ‚úÖ | ‚úÖ | Full parity |
| **Terraform Type Parsing** | ‚úÖ | ‚úÖ | Full parity |

## Common Migration Patterns

### Pattern 1: Validation Function

**Go:**
```go
func ValidateConfig(raw map[string]interface{}) (cty.Value, error) {
    configType := cty.Object(map[string]cty.Type{
        "host": cty.String,
        "port": cty.Number,
    })

    val, err := gocty.ToCtyValue(raw, configType)
    return val, err
}
```

**Python:**
```python
def validate_config(raw: dict) -> CtyValue:
    config_type = CtyObject(
        attribute_types={
            "host": CtyString(),
            "port": CtyNumber(),
        }
    )

    try:
        return config_type.validate(raw)
    except CtyValidationError as e:
        # Handle or re-raise
        raise ValueError(f"Invalid config: {e}") from e
```

### Pattern 2: Iterating Collections

**Go:**
```go
func ProcessList(listVal cty.Value) {
    it := listVal.ElementIterator()
    for it.Next() {
        _, val := it.Element()
        process(val)
    }
}
```

**Python:**
```python
def process_list(list_val: CtyValue) -> None:
    for val in list_val:
        process(val)
```

### Pattern 3: Working with Marks

**Go:**
```go
func RedactSensitive(val cty.Value) cty.Value {
    val, marks := val.Unmark()
    for mark := range marks {
        if mark == "sensitive" {
            return cty.StringVal("[REDACTED]")
        }
    }
    return val
}
```

**Python:**
```python
from pyvider.cty.marks import CtyMark

def redact_sensitive(val: CtyValue) -> CtyValue:
    sensitive = CtyMark("sensitive")
    if sensitive in val.marks:
        return CtyString().validate("[REDACTED]")
    return val.without_all_marks()
```

## Getting Help

If you're migrating from go-cty and need assistance:

- Check the **[How-To: Migrate from go-cty](../how-to/migrate-from-go-cty.md)** guide
- Review the **[API Reference](../api/index.md)** for pyvider.cty equivalents
- Open an issue on [GitHub](https://github.com/provide-io/pyvider-cty/issues)
- Join discussions about migration challenges

## Further Reading

- **[go-cty Documentation](https://pkg.go.dev/github.com/zclconf/go-cty/cty)** - Official go-cty docs
- **[Terraform Type System](https://developer.hashicorp.com/terraform/language/expressions/types)** - Terraform's use of cty
- **[How-To: Work with Terraform](../how-to/work-with-terraform.md)** - Terraform integration guide
>>> EOF >>>

### FILE 32: reference/release-notes.md | checksum=2e9cf5db2aae... | modified=2025-11-15T19:17:59 | op=+ | size=3803 | tokens=919 | type=markdown ###
<<< BOF <<<
# Project Status

This document provides current status and release readiness information for the `pyvider.cty` library.

> **Version History**: For a complete changelog of all releases, see [CHANGELOG.md](https://github.com/provide-io/pyvider-cty/blob/main/CHANGELOG.md).

## Documentation

‚úÖ **Documentation Status: Excellent**

The documentation has been completely restructured to align with provide.io ecosystem patterns:
- New getting started guides with 5-minute quick start
- Comprehensive user guide organized by topic
- Complete API reference with mkdocstrings integration
- Material for MkDocs theme with modern navigation
- All examples updated and organized by category

## Code Quality

‚úÖ **Code Quality: Excellent**

- **Type Checking**: All mypy checks pass with strict mode enabled
- **Code Style**: Follows ruff formatting and linting standards
- **Test Coverage**: Comprehensive test suite covering core functionality
- **Security**: Bandit security analysis passes

## Feature Parity with `go-cty`

The following is a feature comparison matrix between `go-cty` and `pyvider.cty`.

| Feature | `go-cty` | `pyvider.cty` | Notes |
|---|---|---|---|
| **Language** | Go | Python | The most obvious difference is the language. `go-cty` is written in Go, while `pyvider.cty` is written in Python. |
| **API** | The `go-cty` API is designed to be idiomatic Go. | The `pyvider.cty` API is designed to be idiomatic Python. | This means that the two APIs are not directly compatible, but the underlying concepts are the same. |
| **Extensibility** | `go-cty` can be extended with custom types and functions. | `pyvider.cty` can also be extended with custom types and functions. | The mechanism for extension is different in the two libraries. |
| **Performance** | `go-cty` is a compiled language, so it is generally faster than `pyvider.cty`. | `pyvider.cty` is an interpreted language, so it is generally slower than `go-cty`. | However, `pyvider.cty` is still fast enough for most use cases. |
| **Primitive Types** | Yes | Yes | |
| **Collection Types** | Yes | Yes | |
| **Structural Types** | Yes | Yes | |
| **Dynamic Types** | Yes | Yes | |
| **Capsule Types** | Yes | Yes | |
| **Marks** | Yes | Yes | |
| **Functions** | Yes | Yes | `pyvider.cty` has a comprehensive set of built-in functions that is comparable to `go-cty`. |
| **Serialization** | Yes | Yes | `pyvider.cty` supports Msgpack serialization, which is compatible with `go-cty`. |
| **Path Navigation** | Yes | Yes | |
| **Terraform Interoperability** | Yes | Yes | `pyvider.cty` can parse Terraform type strings. |

## Current Release

**Version**: 0.0.1000 (Released: 2025-10-17)
**Status**: Alpha - Production Ready
**Development Status**: Active

### Release Highlights

- **Type System**: Complete implementation of primitives, collections, structural, dynamic, and capsule types
- **Cross-Language Compatibility**: Full MessagePack serialization compatible with go-cty
- **Comprehensive Functions**: 60+ built-in functions for string, numeric, collection, and data manipulation
- **Strong Type Safety**: 100% type coverage with mypy strict mode
- **Test Coverage**: 94% code coverage with 922+ passing tests
- **Documentation**: Complete user guide, API reference, and how-to guides

### Next Release

See [CHANGELOG.md](https://github.com/provide-io/pyvider-cty/blob/main/CHANGELOG.md) for upcoming changes in the next release.

## Production Readiness

‚úÖ **The `pyvider.cty` library is production-ready**

- Documentation is comprehensive and well-organized
- Code quality meets high standards with strict type checking
- Feature set is comparable to go-cty with full cross-language compatibility
- All critical functionality is implemented and tested
- Examples demonstrate all features with working code
>>> EOF >>>

### FILE 33: reference/troubleshooting.md | checksum=2d1c924cfed9... | modified=2025-11-15T19:17:59 | op=+ | size=19303 | tokens=4595 | type=markdown ###
<<< BOF <<<
# Troubleshooting

This guide helps you diagnose and resolve common issues when using `pyvider.cty`.

---

## Quick Lookup Index

**Errors:**
- [CtyValidationError](#ctyvalidationerror) - Data doesn't match schema
- [CtyAttributeValidationError](#ctyattributevalidationerror) - Object attribute validation failed
- [CtyListValidationError](#ctylistvalidationerror) - List validation failed
- [CtyMapValidationError](#ctymapvalidationerror) - Map validation failed
- [CtySetValidationError](#ctysetvalidationerror) - Set validation failed
- [CtyTupleValidationError](#ctytuplevalidationerror) - Tuple validation failed
- [CtyTypeMismatchError](#ctytypemismatcherror) - Wrong data type
- [CtyConversionError](#ctyconversionerror) - Type conversion failed
- [CtyTypeParseError](#ctytypeparseerror) - Type string parsing failed
- [SerializationError](#serializationerror) - MessagePack serialization failed
- [DeserializationError](#deserializationerror) - MessagePack deserialization failed
- [CtyFunctionError](#ctyfunctionerror) - Built-in function error

**Common Scenarios:**
- [Missing Required Attributes](#scenario-1-missing-required-attributes)
- [Type Conversion Issues](#scenario-2-type-conversion-issues)
- [Null vs Missing Attributes](#scenario-3-null-vs-missing-attributes)
- [Accessing Null Values](#scenario-4-accessing-null-values)
- [Recursion Depth Exceeded](#scenario-5-recursion-depth-exceeded)

**Resources:**
- [Debugging Tips](#debugging-tips)
- [Performance Troubleshooting](#performance-troubleshooting)
- [Getting Help](#getting-help)

---

## Exception Hierarchy

Understanding the exception hierarchy helps you catch and handle errors appropriately:

```
CtyError (base exception)
‚îÇ
‚îú‚îÄ‚îÄ CtyValidationError
‚îÇ   ‚îú‚îÄ‚îÄ CtyTypeMismatchError
‚îÇ   ‚îú‚îÄ‚îÄ CtyTypeValidationError
‚îÇ   ‚îú‚îÄ‚îÄ CtyAttributeValidationError
‚îÇ   ‚îú‚îÄ‚îÄ CtyListValidationError
‚îÇ   ‚îú‚îÄ‚îÄ CtyMapValidationError
‚îÇ   ‚îú‚îÄ‚îÄ CtySetValidationError
‚îÇ   ‚îú‚îÄ‚îÄ CtyTupleValidationError
‚îÇ   ‚îú‚îÄ‚îÄ CtyStringValidationError
‚îÇ   ‚îú‚îÄ‚îÄ CtyNumberValidationError
‚îÇ   ‚îú‚îÄ‚îÄ CtyBoolValidationError
‚îÇ   ‚îî‚îÄ‚îÄ CtyCollectionValidationError
‚îÇ
‚îú‚îÄ‚îÄ CtyConversionError
‚îÇ   ‚îú‚îÄ‚îÄ CtyTypeConversionError
‚îÇ   ‚îî‚îÄ‚îÄ CtyTypeParseError
‚îÇ
‚îú‚îÄ‚îÄ CtyFunctionError
‚îÇ
‚îî‚îÄ‚îÄ EncodingError
    ‚îú‚îÄ‚îÄ SerializationError
    ‚îÇ   ‚îú‚îÄ‚îÄ JsonEncodingError
    ‚îÇ   ‚îî‚îÄ‚îÄ MsgPackEncodingError
    ‚îú‚îÄ‚îÄ DeserializationError
    ‚îú‚îÄ‚îÄ WireFormatError
    ‚îú‚îÄ‚îÄ DynamicValueError
    ‚îú‚îÄ‚îÄ InvalidTypeError
    ‚îú‚îÄ‚îÄ AttributePathError
    ‚îî‚îÄ‚îÄ TransformationError
```

**Import Path:** All exceptions can be imported from `pyvider.cty.exceptions`

```python
from pyvider.cty.exceptions import (
    CtyValidationError,
    CtyConversionError,
    SerializationError,
    # ... and others
)
```

**Catching Exceptions:**

```python
from pyvider.cty.exceptions import CtyValidationError, CtyTypeMismatchError

try:
    value = schema.validate(data)
except CtyTypeMismatchError as e:
    # Handle specific type mismatch
    print(f"Type mismatch: {e}")
except CtyValidationError as e:
    # Handle all other validation errors
    print(f"Validation error: {e}")
```

---

## Exception Reference

### Validation Errors

#### `CtyValidationError`

**Description**: Base exception raised when data doesn't conform to a type schema.

**Common Causes**:
- Wrong data type (e.g., string instead of number)
- Missing required attributes in objects
- Invalid collection elements
- Data structure doesn't match schema

**Example**:
```python
from pyvider.cty import CtyObject, CtyString, CtyNumber

user_type = CtyObject(
    attribute_types={"name": CtyString(), "age": CtyNumber()}
)

# This will raise CtyValidationError - missing 'age' attribute
try:
    user = user_type.validate({"name": "Alice"})
except CtyValidationError as e:
    print(f"Validation failed: {e}")
    # Error message will indicate which attribute is missing
```

**How to Fix**:
- Read the error message carefully - it includes the path to the invalid field
- Verify your data structure matches the schema exactly
- Check for typos in attribute names
- Ensure all required fields are present

---

#### `CtyAttributeValidationError`

**Description**: Raised when an object attribute fails validation.

**Common Causes**:
- Missing required attributes
- Extra attributes not defined in schema
- Attribute value doesn't match its type

**Example**:
```python
from pyvider.cty import CtyObject, CtyString

person_type = CtyObject(attribute_types={"name": CtyString()})

# This will raise CtyAttributeValidationError - 'age' not in schema
try:
    person = person_type.validate({"name": "Bob", "age": 30})
except CtyAttributeValidationError as e:
    print(f"Attribute error: {e}")
```

**How to Fix**:
- Use `optional_attributes` parameter for optional fields
- Remove extra attributes from data or add them to the schema
- Verify attribute types match the schema

---

#### `CtyListValidationError`

**Description**: Raised when list validation fails.

**Common Causes**:
- Element doesn't match the list's element type
- Non-list value passed to list type
- Heterogeneous elements in a homogeneous list

**Example**:
```python
from pyvider.cty import CtyList, CtyString

tags_type = CtyList(element_type=CtyString())

# This will raise CtyListValidationError - contains number
try:
    tags = tags_type.validate(["tag1", "tag2", 123])
except CtyListValidationError as e:
    print(f"List validation failed: {e}")
```

**How to Fix**:
- Ensure all elements match the declared element type
- Check for type mismatches in the list
- Use `CtyDynamic` if you need heterogeneous lists

---

#### `CtyMapValidationError`

**Description**: Raised when map validation fails.

**Common Causes**:
- Value doesn't match the map's element type
- Non-string keys
- Non-dict value passed to map type

**Example**:
```python
from pyvider.cty import CtyMap, CtyNumber

config_type = CtyMap(element_type=CtyNumber())

# This will raise CtyMapValidationError - "three" is not a number
try:
    config = config_type.validate({"one": 1, "two": 2, "three": "3"})
except CtyMapValidationError as e:
    print(f"Map validation failed: {e}")
```

**How to Fix**:
- Ensure all values match the declared element type
- Verify all keys are strings
- Check the data structure is a dictionary

---

#### `CtySetValidationError`

**Description**: Raised when set validation fails.

**Common Causes**:
- Element doesn't match the set's element type
- Duplicate elements in input
- Unhashable elements

**Example**:
```python
from pyvider.cty import CtySet, CtyString

unique_tags_type = CtySet(element_type=CtyString())

# This will raise CtySetValidationError - contains number
try:
    tags = unique_tags_type.validate({"tag1", "tag2", 123})
except CtySetValidationError as e:
    print(f"Set validation failed: {e}")
```

**How to Fix**:
- Ensure all elements match the declared element type
- Remove duplicates if present
- Verify elements are hashable

---

#### `CtyTupleValidationError`

**Description**: Raised when tuple validation fails.

**Common Causes**:
- Wrong number of elements
- Element at specific position doesn't match expected type
- Non-sequence value passed to tuple type

**Example**:
```python
from pyvider.cty import CtyTuple, CtyString, CtyNumber

point_type = CtyTuple(element_types=[CtyString(), CtyNumber(), CtyNumber()])

# This will raise CtyTupleValidationError - wrong number of elements
try:
    point = point_type.validate(["origin", 0])  # Missing third element
except CtyTupleValidationError as e:
    print(f"Tuple validation failed: {e}")
```

**How to Fix**:
- Ensure exactly the right number of elements
- Verify each element matches its positional type
- Check element order matches the schema

---

#### `CtyTypeMismatchError`

**Description**: Raised when value type doesn't match expected type.

**Common Causes**:
- Passing completely wrong type (e.g., dict instead of list)
- Type confusion in nested structures

**Example**:
```python
from pyvider.cty import CtyString

string_type = CtyString()

# This will raise CtyTypeMismatchError
try:
    value = string_type.validate(123)  # Number instead of string
except CtyTypeMismatchError as e:
    print(f"Type mismatch: {e}")
```

**How to Fix**:
- Verify the data type matches the schema
- Check for type confusion (list vs dict, string vs number)
- Use type conversion if appropriate

---

### Conversion Errors

#### `CtyConversionError`

**Description**: Base exception for type conversion failures.

**Common Causes**:
- Attempting to convert between incompatible types
- Invalid string format when converting to number
- Conversion would lose data or precision

**Example**:
```python
from pyvider.cty import CtyString, CtyNumber, convert

string_val = CtyString().validate("not-a-number")

# This will raise CtyConversionError
try:
    number_val = convert(string_val, CtyNumber())
except CtyConversionError as e:
    print(f"Conversion failed: {e}")
```

**How to Fix**:
- Check if the conversion is logically valid
- Verify string format when converting to numbers
- Use validation instead of conversion when appropriate
- Consider using `CtyDynamic` for unknown types

---

#### `CtyTypeParseError`

**Description**: Raised when parsing a type string fails.

**Common Causes**:
- Invalid Terraform type string syntax
- Unsupported type in string
- Malformed type expression

**Example**:
```python
from pyvider.cty import parse_tf_type_to_ctytype

# This will raise CtyTypeParseError - invalid syntax
try:
    parsed_type = parse_tf_type_to_ctytype("invalid[type{syntax")
except CtyTypeParseError as e:
    print(f"Parse error: {e}")
```

**How to Fix**:
- Verify the type string syntax is correct
- Check for matching brackets and braces
- Refer to Terraform type syntax documentation
- Use explicit type construction instead of parsing

---

### Serialization Errors

#### `SerializationError`

**Description**: Raised when serializing a value to MessagePack fails.

**Common Causes**:
- Unsupported data type in value
- Circular references
- Capsule types without proper serialization support

**Example**:
```python
from pyvider.cty import CtyObject, CtyString
from pyvider.cty.codec import cty_to_msgpack
from pyvider.cty.exceptions import SerializationError

schema = CtyObject(attribute_types={"key": CtyString()})
value = schema.validate({"key": "value"})

# Normally this works, but can fail with incompatible data
try:
    msgpack_bytes = cty_to_msgpack(value, schema)
except SerializationError as e:
    print(f"Serialization failed: {e}")
```

**How to Fix**:
- Ensure all data types are serializable
- Check for circular references in capsule types
- Verify capsule types implement proper serialization

---

#### `DeserializationError`

**Description**: Raised when deserializing MessagePack data fails.

**Common Causes**:
- Corrupted MessagePack data
- Schema mismatch between serialization and deserialization
- Invalid MessagePack format

**Example**:
```python
from pyvider.cty import CtyObject, CtyString
from pyvider.cty.codec import cty_from_msgpack
from pyvider.cty.exceptions import DeserializationError

schema = CtyObject(attribute_types={"key": CtyString()})

# This will raise DeserializationError - invalid data
try:
    value = cty_from_msgpack(b"invalid msgpack data", schema)
except DeserializationError as e:
    print(f"Deserialization failed: {e}")
```

**How to Fix**:
- Verify the MessagePack data is not corrupted
- Ensure the same schema is used for serialization and deserialization
- Check data was actually serialized with cty_to_msgpack

---

### Function Errors

#### `CtyFunctionError`

**Description**: Raised when a built-in function fails.

**Common Causes**:
- Invalid arguments to function
- Null or unknown values where concrete values expected
- Type mismatch in function parameters

**Example**:
```python
from pyvider.cty import CtyString
from pyvider.cty.functions import upper
from pyvider.cty.exceptions import CtyFunctionError

# This will raise CtyFunctionError - null value
try:
    null_val = CtyString().validate(None)
    result = upper(null_val)
except CtyFunctionError as e:
    print(f"Function error: {e}")
```

**How to Fix**:
- Check function documentation for argument requirements
- Verify values are not null or unknown unless function supports it
- Ensure argument types match function expectations

---

## Common Scenarios

### Scenario 1: Missing Required Attributes

**Problem**:
```python
from pyvider.cty import CtyObject, CtyString, CtyNumber

schema = CtyObject(
    attribute_types={
        "name": CtyString(),
        "age": CtyNumber(),
    }
)

# Error: missing 'age'
data = {"name": "Alice"}
value = schema.validate(data)  # Raises CtyValidationError
```

**Solution**:
```python
# Option 1: Make 'age' optional
schema = CtyObject(
    attribute_types={"name": CtyString(), "age": CtyNumber()},
    optional_attributes={"age"}
)
value = schema.validate({"name": "Alice"})  # Works!

# Option 2: Provide all required fields
value = schema.validate({"name": "Alice", "age": 30})  # Works!
```

---

### Scenario 2: Type Conversion Issues

**Problem**:
```python
from pyvider.cty import CtyNumber

number_type = CtyNumber()
value = number_type.validate("123")  # Raises CtyTypeMismatchError
```

**Solution**:
```python
# Option 1: Use conversion
from pyvider.cty import CtyString, convert

string_val = CtyString().validate("123")
number_val = convert(string_val, CtyNumber())  # Works!

# Option 2: Provide correct type
value = number_type.validate(123)  # Works!
```

---

### Scenario 3: Null vs Missing Attributes

**Problem**:
```python
from pyvider.cty import CtyObject, CtyString, CtyValue

schema = CtyObject(
    attribute_types={"name": CtyString(), "nickname": CtyString()},
    optional_attributes={"nickname"}
)

# What's the difference between these?
data1 = {"name": "Alice"}                    # nickname is missing
data2 = {"name": "Alice", "nickname": None}  # nickname is explicitly null
```

**Solution**:
```python
# Missing optional attribute becomes null automatically
value1 = schema.validate(data1)
print(value1["nickname"].is_null)  # True

# Explicit None also becomes null
value2 = schema.validate(data2)
print(value2["nickname"].is_null)  # True

# Both are equivalent in cty
```

---

### Scenario 4: Accessing Null Values

**Problem**:
```python
from pyvider.cty import CtyObject, CtyString

schema = CtyObject(
    attribute_types={"name": CtyString()},
    optional_attributes={"name"}
)

value = schema.validate({})
name = value["name"].raw_value  # Raises error - can't get raw_value of null
```

**Solution**:
```python
# Check for null before accessing
value = schema.validate({})
if value["name"].is_null:
    print("Name is not provided")
else:
    print(f"Name: {value['name'].raw_value}")
```

---

### Scenario 5: Recursion Depth Exceeded

**Problem**:
```python
# Creating extremely deep nested structure
deep_data = {"level": {}}
current = deep_data["level"]
for i in range(1000):
    current["level"] = {}
    current = current["level"]

# This may raise recursion depth error
```

**Solution**:
```python
from pyvider.cty.context import MAX_VALIDATION_DEPTH

# The default limit is 500 levels
# If you need deeper structures, consider:
# 1. Flattening your data structure
# 2. Using references instead of deep nesting
# 3. Adjusting MAX_VALIDATION_DEPTH (with caution)
```

---

## Debugging Tips

### 1. Enable Detailed Error Messages

Validation errors include the full path to the problematic field:

```python
try:
    value = complex_schema.validate(data)
except CtyValidationError as e:
    print(f"Error at: {e}")
    # Example output: "at path.users[2].address.city: expected CtyString, got int"
```

### 2. Inspect Raw Values

When debugging, inspect the raw Python values:

```python
from pyvider.cty import CtyObject, CtyString

schema = CtyObject(attribute_types={"name": CtyString()})
data = {"name": "Alice"}

print(f"Raw data: {repr(data)}")
value = schema.validate(data)
print(f"Validated value: {value}")
print(f"Name raw value: {value['name'].raw_value}")
```

### 3. Use a Debugger

Set breakpoints in your validation code:

```python
import pdb

try:
    value = schema.validate(data)
except CtyValidationError as e:
    pdb.set_trace()  # Drop into debugger to inspect state
```

### 4. Simplify the Problem

When dealing with complex structures, test incrementally:

```python
# Instead of validating everything at once
full_data = {"user": {"profile": {"settings": {...}}}}

# Test each level separately
user_data = {"profile": {...}}
profile_data = {"settings": {...}}

# Validate from inside out
settings_value = settings_schema.validate(settings_data)
profile_value = profile_schema.validate(profile_data)
user_value = user_schema.validate(user_data)
```

### 5. Check Type Compatibility

Use the type system to verify compatibility:

```python
from pyvider.cty import CtyString, CtyNumber, unify

# Check if types can be unified
try:
    unified_type = unify([CtyString(), CtyNumber()])
    print(f"Unified to: {unified_type}")
except Exception as e:
    print(f"Types are incompatible: {e}")
```

### 6. Validate Incrementally

For complex nested structures, validate step by step:

```python
# Bad: One massive validation that's hard to debug
full_config = {...deeply nested...}
config_value = config_schema.validate(full_config)

# Good: Validate subsections
db_value = db_schema.validate(config["database"])
api_value = api_schema.validate(config["api"])
full_value = full_schema.validate({"database": db_value, "api": api_value})
```

---

## Performance Troubleshooting

### Large Data Structures

**Problem**: Validation is slow for large datasets.

**Solutions**:
- Cache schema objects - don't recreate types repeatedly
- Validate once, reuse the validated `CtyValue`
- Consider batching for very large datasets
- Profile to identify bottlenecks

```python
# Bad: Creating schema inside loop
for item in large_dataset:
    schema = CtyObject(attribute_types={"field": CtyString()})  # Recreated every time!
    value = schema.validate(item)

# Good: Create schema once
schema = CtyObject(attribute_types={"field": CtyString()})
for item in large_dataset:
    value = schema.validate(item)
```

### Deep Nesting

**Problem**: Deeply nested structures cause performance issues.

**Solutions**:
- Flatten data structures where possible
- Use references instead of deep nesting
- Consider alternative data modeling

---

## Getting Help

If you're still stuck after consulting this guide:

1. **Check the documentation**: Review the [User Guide](../user-guide/index.md) and [API Reference](../api/index.md)
2. **Review examples**: Look at the [Examples](../getting-started/examples.md) for similar use cases
3. **Search issues**: Check [GitHub Issues](https://github.com/provide-io/pyvider-cty/issues) for similar problems
4. **Ask for help**: Open a new issue with a minimal reproducible example

When reporting issues, include:
- Complete error message and stack trace
- Minimal code example that reproduces the issue
- Your Python version and pyvider.cty version
- What you expected vs what actually happened
>>> EOF >>>

### FILE 34: user-guide/advanced/functions.md | checksum=b566452f2c46... | modified=2025-11-15T19:17:59 | op=+ | size=5075 | tokens=1224 | type=markdown ###
<<< BOF <<<
# Chapter 11: Functions

`pyvider.cty` provides a rich, built-in standard library of functions for manipulating `cty` values. These functions are type-safe and operate on `CtyValue` instances, returning new `CtyValue` instances.

## Calling Functions

You can call a `cty` function by importing it from the `pyvider.cty.functions` module.

```python
from pyvider.cty import CtyNumber
from pyvider.cty.functions import add, abs_fn

num1 = CtyNumber().validate(10)
num2 = CtyNumber().validate(-20)

# Add two numbers
sum_val = add(num1, num2)
assert sum_val.raw_value == -10

# Get the absolute value
abs_val = abs_fn(num2)
assert abs_val.raw_value == 20
```

## Overview of Available Functions

The standard library is extensive. Below is a categorized overview with function descriptions.

### Numeric Functions

| Function | Description |
|----------|-------------|
| `add` | Add two numbers |
| `subtract` | Subtract second number from first |
| `multiply` | Multiply two numbers |
| `divide` | Divide first number by second |
| `modulo` | Calculate modulo (remainder) of division |
| `pow_fn` | Raise first number to power of second |
| `abs_fn` | Return absolute value of a number |
| `ceil_fn` | Round number up to nearest integer |
| `floor_fn` | Round number down to nearest integer |
| `int_fn` | Convert number to integer (truncate decimals) |
| `log_fn` | Calculate natural logarithm |
| `signum_fn` | Return sign of number (-1, 0, or 1) |
| `parseint_fn` | Parse string as integer in given base |
| `negate` | Negate a number (multiply by -1) |
| `max_fn` | Return maximum of two numbers |
| `min_fn` | Return minimum of two numbers |

### String Functions

| Function | Description |
|----------|-------------|
| `upper` | Convert string to uppercase |
| `lower` | Convert string to lowercase |
| `title` | Convert string to title case |
| `strrev` | Reverse a string |
| `chomp` | Remove trailing newline from string |
| `indent` | Add indentation to each line |
| `trim` | Remove leading and trailing whitespace |
| `trimspace` | Remove all leading/trailing whitespace |
| `trimprefix` | Remove prefix from string if present |
| `trimsuffix` | Remove suffix from string if present |
| `join` | Join list of strings with separator |
| `split` | Split string by separator into list |
| `replace` | Replace occurrences of substring |
| `substr` | Extract substring by position and length |
| `regex` | Match string against regular expression |
| `regexall` | Find all regex matches in string |
| `regexreplace` | Replace regex matches in string |

### Collection Functions

| Function | Description |
|----------|-------------|
| `length` | Return number of elements in collection |
| `slice` | Extract subset of list elements |
| `concat` | Concatenate multiple lists |
| `contains` | Check if collection contains value |
| `reverse` | Reverse order of list elements |
| `distinct` | Remove duplicate elements from list |
| `flatten` | Flatten nested lists into single list |
| `sort` | Sort list elements |
| `keys` | Get keys from map or object |
| `values` | Get values from map or object |
| `lookup` | Look up value in map by key with default |
| `merge` | Merge multiple maps into one |
| `zipmap` | Create map from list of keys and list of values |
| `element` | Get element at specific index (with wraparound) |
| `chunklist` | Split list into chunks of specified size |
| `setproduct` | Calculate Cartesian product of sets |
| `compact` | Remove null/empty values from list |
| `coalescelist` | Return first non-empty list |
| `index` | Find index of value in list |
| `hasindex` | Check if collection has element at index |

### Comparison Functions

| Function | Description |
|----------|-------------|
| `equal` | Test if two values are equal |
| `not_equal` | Test if two values are not equal |
| `greater_than` | Test if first > second |
| `less_than` | Test if first < second |
| `greater_than_or_equal_to` | Test if first >= second |
| `less_than_or_equal_to` | Test if first <= second |

### Type Conversion Functions

| Function | Description |
|----------|-------------|
| `to_string` | Convert value to string |
| `to_number` | Convert value to number |
| `to_bool` | Convert value to boolean |

### Encoding Functions

| Function | Description |
|----------|-------------|
| `jsonencode` | Encode value as JSON string |
| `jsondecode` | Decode JSON string to value |
| `csvdecode` | Decode CSV string to list of maps |

### Date/Time Functions

| Function | Description |
|----------|-------------|
| `formatdate` | Format timestamp string using format spec |
| `timeadd` | Add duration to timestamp |

### Bytes Functions

| Function | Description |
|----------|-------------|
| `byteslen` | Return length of bytes value |
| `bytesslice` | Extract slice of bytes |

### Structural Functions

| Function | Description |
|----------|-------------|
| `coalesce` | Return first non-null value from arguments |

For complete API documentation with detailed signatures and examples, see the **[Functions API Reference](../../api/functions.md)**.
>>> EOF >>>

### FILE 35: user-guide/advanced/marks.md | checksum=80763c7c9eef... | modified=2025-11-15T19:17:59 | op=+ | size=3504 | tokens=832 | type=markdown ###
<<< BOF <<<
# Marks System

Marks are a powerful feature in `pyvider.cty` that allow you to attach metadata to `cty` values. This metadata can then be used to add extra information to the values, such as sensitivity, or to control how the values are processed in a data pipeline.

## What are Marks?

A mark is a piece of metadata that is attached to a `cty` value. Marks are represented as `CtyMark` objects, and a single value can have multiple marks.

Marks are "sticky". This means that when you perform an operation on a marked value, the marks are automatically transferred to the resulting value.

## Marking a Value

You can mark a value using the `mark` method (for a single mark) or `with_marks` method (for multiple marks) of a `cty` value:

```python
from pyvider.cty import CtyString
from pyvider.cty.marks import CtyMark

# Create a string value
cty_string = CtyString().validate("hello")

# Create a mark
sensitive_mark = CtyMark("sensitive")

# Mark the value as "sensitive" using the mark() method
sensitive_string = cty_string.mark(sensitive_mark)
```

You can also add multiple marks at once using `with_marks`, which accepts a set of marks:

```python
# Create multiple marks
sensitive_mark = CtyMark("sensitive")
private_mark = CtyMark("private")

# Mark the value with both marks
private_sensitive_string = cty_string.with_marks({sensitive_mark, private_mark})
```

Marks can optionally include additional details:

```python
# Create a mark with details
pii_mark = CtyMark("pii", details={"category": "email", "source": "user_input"})
marked_value = cty_string.mark(pii_mark)
```

## Checking for Marks

You can check if a value has a specific mark by checking if it's in the `marks` property:

```python
sensitive_mark = CtyMark("sensitive")
sensitive_string = cty_string.mark(sensitive_mark)

# Check using 'in' operator
assert sensitive_mark in sensitive_string.marks

# Or use the has_mark() method
assert sensitive_string.has_mark(sensitive_mark)
```

You can also get a frozenset of all the marks on a value using the `marks` property:

```python
assert len(sensitive_string.marks) == 1
```

## Removing Marks

To remove all marks from a value, use the `unmark` method, which returns both the unmarked value and the marks that were removed:

```python
unmarked_value, removed_marks = sensitive_string.unmark()
assert len(unmarked_value.marks) == 0
assert sensitive_mark in removed_marks
```

## Use Cases for Marks

Marks are a flexible feature that can be used in a variety of ways. Here are a few examples:

*   **Sensitive Data**: You can use marks to flag sensitive data, such as passwords or API keys. You can then use these marks to ensure that the data is handled appropriately, such as by redacting it from logs or encrypting it before storing it.

*   **Data Lineage**: You can use marks to track the lineage of data as it flows through a data pipeline. This can be useful for debugging and for understanding how a particular value was derived.

*   **Controlling Behavior**: You can use marks to control the behavior of functions and other operations. For example, you could create a function that only operates on values that have a specific mark.

## See Also

- **[Terraform Interoperability](terraform-interop.md)** - Using marks with Terraform sensitive values
- **[Working with Values](../core-concepts/values.md)** - Understanding CtyValue properties
- **[go-cty Comparison](../../reference/go-cty-comparison.md)** - Marks API differences between go-cty and pyvider.cty
>>> EOF >>>

### FILE 36: user-guide/advanced/path-navigation.md | checksum=d2bbeb579208... | modified=2025-11-15T19:17:59 | op=+ | size=2182 | tokens=549 | type=markdown ###
<<< BOF <<<
# Path Navigation

`pyvider.cty` provides a powerful path language to navigate and access elements within complex `CtyValue` structures. This is particularly useful for debugging, validation, and extracting specific data from nested objects and collections.

## The `CtyPath` Class

The `CtyPath` class is the core of the path language. It represents a sequence of steps to navigate through a `CtyValue`.

### Creating a Path

You can create a path using the class methods of `CtyPath`:

```python
from pyvider.cty.path import CtyPath

# Path to an attribute
path_to_attr = CtyPath.get_attr("my_attr")

# Path to a list/tuple element
path_to_index = CtyPath.index(0)

# Path to a map key
path_to_key = CtyPath.key("my_key")
```

Paths can be chained together to create more complex navigation:

```python
complex_path = CtyPath.get_attr("users").index(0).child("name")
```

### Applying a Path

The `apply_path` method of a `CtyPath` object is used to navigate to a specific element within a `CtyValue`:

```python
from pyvider.cty import CtyObject, CtyString

# Create a CtyValue
user_type = CtyObject(attribute_types={"name": CtyString()})
user_val = user_type.validate({"name": "Alice"})

# Create a path
name_path = CtyPath.get_attr("name")

# Apply the path
name_val = name_path.apply_path(user_val)

assert name_val.raw_value == "Alice"
```

### Applying a Path to a Type

The `apply_path_type` method of a `CtyPath` object is used to determine the type of the element that the path would navigate to:

```python
from pyvider.cty import CtyObject, CtyString
from pyvider.cty.path import CtyPath

user_type = CtyObject(attribute_types={"name": CtyString()})
name_path = CtyPath.get_attr("name")

# Apply the path to the type
name_type = name_path.apply_path_type(user_type)

assert name_type == CtyString()
```

This is useful for static analysis and validation without needing an actual `CtyValue`.

## See Also

- **[Path API Reference](../../api/path.md)** - Complete path navigation API
- **[Structural Types](../type-reference/structural.md)** - Working with Object and Tuple types
- **[Troubleshooting](../../reference/troubleshooting.md)** - Debugging nested structures
>>> EOF >>>

### FILE 37: user-guide/advanced/serialization.md | checksum=70420976429d... | modified=2025-11-15T19:17:59 | op=+ | size=10043 | tokens=2386 | type=markdown ###
<<< BOF <<<
# Serialization

Serialization is the process of converting your in-memory `CtyValue` into a format (like a byte sequence) that can be easily stored or transmitted. Deserialization is the reverse: taking that stored format and faithfully reconstructing the original `CtyValue`.

`pyvider.cty` provides built-in support for **MessagePack**, a binary format that's compact, fast, and **fully compatible with HashiCorp's go-cty**. This is the primary and recommended serialization format for cross-language interoperability with Terraform providers and other Go-based tools.

## Key Concepts

1.  **Type Fidelity**: `pyvider.cty`'s serialization aims to preserve as much type information and value precision as possible. The serialized form includes information about the value's `cty` type, its actual data, its known/null status, and any marks.

2.  **Handling of Null and Unknown Values**: Null and unknown values are explicitly represented in the serialized output, so they can be correctly restored.

3.  **The Role of `target_type` in Deserialization**: When you deserialize data, you **must** provide the `target_type`‚Äîthe `CtyType` you expect the data to conform to. This guides the reconstruction process and ensures the data is validated against the correct schema.

## MessagePack Serialization

The `pyvider.cty.codec` module provides functions for MessagePack serialization.

*   `cty_to_msgpack(value: CtyValue, schema: CtyType) -> bytes`: Serializes a `CtyValue` to a MessagePack byte string.
*   `cty_from_msgpack(data: bytes, cty_type: CtyType) -> CtyValue`: Deserializes a MessagePack byte string to a `CtyValue`.

### Basic Example

```python
from pyvider.cty import CtyString, CtyObject
from pyvider.cty.codec import cty_to_msgpack, cty_from_msgpack

# 1. Define a type and a CtyValue
user_type = CtyObject(attribute_types={"name": CtyString()})
user_value = user_type.validate({"name": "Alice"})

# 2. Serialize to MessagePack
msgpack_bytes = cty_to_msgpack(user_value, user_type)
print(f"Serialized to {len(msgpack_bytes)} bytes")

# 3. Deserialize from MessagePack
reconstructed_value = cty_from_msgpack(msgpack_bytes, user_type)

assert reconstructed_value == user_value
```

### Complex Structures

MessagePack serialization works seamlessly with complex, nested structures:

```python
from pyvider.cty import CtyObject, CtyString, CtyNumber, CtyList, CtyBool
from pyvider.cty.codec import cty_to_msgpack, cty_from_msgpack

# Define a complex nested type
config_type = CtyObject(
    attribute_types={
        "database": CtyObject(
            attribute_types={
                "host": CtyString(),
                "port": CtyNumber(),
                "replicas": CtyList(element_type=CtyString()),
            }
        ),
        "features": CtyObject(
            attribute_types={
                "enabled": CtyBool(),
                "flags": CtyList(element_type=CtyString()),
            }
        ),
    }
)

# Create and validate data
config_data = {
    "database": {
        "host": "localhost",
        "port": 5432,
        "replicas": ["replica1", "replica2"],
    },
    "features": {
        "enabled": True,
        "flags": ["feature_a", "feature_b"],
    },
}

config_value = config_type.validate(config_data)

# Serialize
msgpack_bytes = cty_to_msgpack(config_value, config_type)

# Deserialize
reconstructed = cty_from_msgpack(msgpack_bytes, config_type)
assert reconstructed == config_value
```

### Preserving Null and Unknown Values

MessagePack serialization correctly preserves null and unknown values:

```python
from pyvider.cty import CtyObject, CtyString, CtyNumber, CtyValue
from pyvider.cty.codec import cty_to_msgpack, cty_from_msgpack

user_type = CtyObject(
    attribute_types={
        "name": CtyString(),
        "age": CtyNumber(),
    },
    optional_attributes={"age"}
)

# Create a value with a null attribute
user_data = {"name": "Bob"}  # age will be null
user_value = user_type.validate(user_data)

# Serialize and deserialize
msgpack_bytes = cty_to_msgpack(user_value, user_type)
reconstructed = cty_from_msgpack(msgpack_bytes, user_type)

# Null is preserved
assert reconstructed["age"].is_null
```

### Preserving Marks

Marks (metadata) are preserved during serialization:

```python
from pyvider.cty import CtyString
from pyvider.cty.marks import CtyMark
from pyvider.cty.codec import cty_to_msgpack, cty_from_msgpack

string_type = CtyString()
sensitive_mark = CtyMark("sensitive")

# Create a marked value
password = string_type.validate("secret123")
marked_password = password.with_marks({sensitive_mark})

# Serialize and deserialize
msgpack_bytes = cty_to_msgpack(marked_password, string_type)
reconstructed = cty_from_msgpack(msgpack_bytes, string_type)

# Marks are preserved
assert sensitive_mark in reconstructed.marks
```

## JSON Support

For JSON workflows, `pyvider.cty` provides the `jsonencode()` and `jsondecode()` functions in the `pyvider.cty.functions` module. These work with JSON strings as `CtyValue` objects:

```python
from pyvider.cty import CtyObject, CtyString, CtyNumber
from pyvider.cty.functions import jsonencode, jsondecode

# Create a value
user_type = CtyObject(
    attribute_types={"name": CtyString(), "age": CtyNumber()}
)
user_value = user_type.validate({"name": "Alice", "age": 30})

# Encode to JSON string (returns CtyValue containing a JSON string)
json_string_value = jsonencode(user_value)
json_str = json_string_value.raw_value  # Get the actual JSON string

print(f"JSON: {json_str}")
# Output: JSON: {"name":"Alice","age":30}

# Decode from JSON string
json_input = CtyString().validate('{"name":"Bob","age":25}')
decoded_value = jsondecode(json_input)

# Note: jsondecode returns dynamic data, may need type conversion
```

**Key Difference**: Unlike MessagePack serialization which is designed for storage and transmission, `jsonencode`/`jsondecode` are for working with JSON data as strings within the cty type system.

## Cross-Language Compatibility

The MessagePack format is **fully compatible** with go-cty, enabling seamless data exchange:

```python
# Python serializes data
from pyvider.cty import CtyObject, CtyString
from pyvider.cty.codec import cty_to_msgpack

schema = CtyObject(attribute_types={"message": CtyString()})
value = schema.validate({"message": "Hello from Python"})
msgpack_data = cty_to_msgpack(value, schema)

# This msgpack_data can be sent to a Go application using go-cty
# Go can deserialize it with: msgpack.Unmarshal(msgpack_data, goSchema)

# Similarly, data serialized by go-cty can be deserialized by pyvider.cty
```

## Storage and Transmission

### Saving to File

```python
from pyvider.cty import CtyObject, CtyString
from pyvider.cty.codec import cty_to_msgpack, cty_from_msgpack

config_type = CtyObject(attribute_types={"setting": CtyString()})
config_value = config_type.validate({"setting": "production"})

# Serialize and save
msgpack_bytes = cty_to_msgpack(config_value, config_type)
with open("config.msgpack", "wb") as f:
    f.write(msgpack_bytes)

# Load and deserialize
with open("config.msgpack", "rb") as f:
    loaded_bytes = f.read()
loaded_value = cty_from_msgpack(loaded_bytes, config_type)

assert loaded_value == config_value
```

### Network Transmission

```python
import socket
from pyvider.cty import CtyObject, CtyString
from pyvider.cty.codec import cty_to_msgpack, cty_from_msgpack

data_type = CtyObject(attribute_types={"payload": CtyString()})

# Serialize for transmission
data = data_type.validate({"payload": "important data"})
msgpack_bytes = cty_to_msgpack(data, data_type)

# Send over network (example with sockets)
# sock.sendall(msgpack_bytes)

# Receive and deserialize
# received_bytes = sock.recv(4096)
# reconstructed = cty_from_msgpack(received_bytes, data_type)
```

## Performance Considerations

**MessagePack Benefits:**
- **Compact**: Typically smaller than JSON
- **Fast**: Binary format is faster to parse than text-based JSON
- **Type-safe**: Preserves type information and cty semantics
- **Compatible**: Works seamlessly with go-cty

**When to Use MessagePack:**
- Storing configuration data
- Transmitting data between Python and Go services
- Working with Terraform providers
- Any scenario requiring type fidelity and performance

**When to Use JSON Functions:**
- When you need human-readable output
- Integrating with JSON-based APIs
- Debugging and inspection
- When cross-language compatibility with non-cty systems is needed

## Best Practices

1. **Always provide the type during deserialization**: The type parameter is required for proper reconstruction
2. **Cache schemas**: Don't recreate `CtyType` instances repeatedly; create once and reuse
3. **Handle serialization errors**: Wrap serialize/deserialize calls in try-except blocks
4. **Validate after deserialization**: While the type is enforced during deserialization, consider additional validation for external data
5. **Use MessagePack for production**: Prefer MessagePack over JSON for production systems requiring reliability and performance

## Error Handling

```python
from pyvider.cty import CtyObject, CtyString
from pyvider.cty.codec import cty_to_msgpack, cty_from_msgpack
from pyvider.cty.exceptions import SerializationError, DeserializationError

schema = CtyObject(attribute_types={"key": CtyString()})

try:
    value = schema.validate({"key": "value"})
    msgpack_bytes = cty_to_msgpack(value, schema)
except SerializationError as e:
    print(f"Serialization failed: {e}")

try:
    # Attempt to deserialize potentially corrupted data
    reconstructed = cty_from_msgpack(msgpack_bytes, schema)
except DeserializationError as e:
    print(f"Deserialization failed: {e}")
```

## Related Topics

- **[Codec API Reference](../../api/codec.md)** - Complete API documentation
- **[Functions Reference](../../api/functions.md)** - JSON encoding functions
- **[Terraform Interoperability](terraform-interop.md)** - Working with Terraform
- **[Go-Cty Comparison](../../reference/go-cty-comparison.md)** - Serialization compatibility details
>>> EOF >>>

### FILE 38: user-guide/advanced/terraform-interop.md | checksum=232e2d3c87ed... | modified=2025-11-15T19:17:59 | op=+ | size=19540 | tokens=4426 | type=markdown ###
<<< BOF <<<
# Terraform Interoperability

`pyvider.cty` is designed for seamless interoperability with HashiCorp's Terraform ecosystem. This enables Python-based Terraform providers, state manipulation tools, and configuration validators that work natively with Terraform's type system.

## Overview

Terraform uses the `go-cty` type system internally for all type checking and value handling. `pyvider.cty` implements the same type system in Python with full cross-language compatibility, allowing you to:

- **Build Terraform Providers in Python**: Create custom providers using the Terraform Plugin Framework
- **Parse Terraform Type Strings**: Convert Terraform type syntax to pyvider.cty types
- **Exchange Data with Terraform**: Use MessagePack for binary-compatible serialization
- **Validate Terraform Configurations**: Type-check variables, resources, and modules
- **Manipulate Terraform State**: Read and modify state files safely

## Type String Parsing

Terraform represents types as strings like `list(string)` or `object({name=string})`. The `parse_tf_type_to_ctytype` function converts these to pyvider.cty types.

### Basic Type Parsing

```python
from pyvider.cty.parser import parse_tf_type_to_ctytype

# Primitive types
string_type = parse_tf_type_to_ctytype("string")
number_type = parse_tf_type_to_ctytype("number")
bool_type = parse_tf_type_to_ctytype("bool")

# Collection types
list_type = parse_tf_type_to_ctytype("list(string)")
map_type = parse_tf_type_to_ctytype("map(number)")
set_type = parse_tf_type_to_ctytype("set(string)")
```

### Complex Type Parsing

```python
# Object types
person_type = parse_tf_type_to_ctytype("""
    object({
        name = string,
        age = number,
        active = bool
    })
""")

# Nested collections
nested_type = parse_tf_type_to_ctytype("""
    list(object({
        id = string,
        tags = map(string)
    }))
""")

# Tuple types
tuple_type = parse_tf_type_to_ctytype("tuple([string, number, bool])")
```

### Alternative Format: JSON Arrays

Terraform also represents types as JSON arrays:

```python
# ["list", "string"] format
list_type = parse_tf_type_to_ctytype(["list", "string"])

# ["object", {...}] format
object_type = parse_tf_type_to_ctytype([
    "object",
    {
        "name": "string",
        "age": "number"
    }
])

# Verify equivalence
from pyvider.cty import CtyList, CtyString

assert list_type == CtyList(element_type=CtyString())
```

## MessagePack Serialization

Terraform uses MessagePack for efficient binary serialization of cty values. `pyvider.cty` provides full compatibility.

### Cross-Language Exchange

```python
from pyvider.cty.codec import cty_to_msgpack, cty_from_msgpack
from pyvider.cty import CtyObject, CtyString, CtyNumber

# Define schema
schema = CtyObject(
    attribute_types={
        "name": CtyString(),
        "age": CtyNumber()
    }
)

# Create value
value = schema.validate({"name": "Alice", "age": 30})

# Serialize to MessagePack (Terraform-compatible)
msgpack_bytes = cty_to_msgpack(value, schema)

# This binary data can be:
# - Sent to a Terraform provider written in Go
# - Stored in Terraform state files
# - Exchanged with any go-cty application

# Deserialize back
restored = cty_from_msgpack(msgpack_bytes, schema)
assert restored['name'].raw_value == "Alice"
```

### Interop with Go Providers

```python
# Python provider sends data to Terraform
def create_resource(config):
    """Create resource and return state as MessagePack."""
    # Validate configuration
    validated_config = resource_schema.validate(config)

    # Perform resource creation...
    resource_state = {
        "id": "res-12345",
        "name": validated_config['name'].raw_value,
        "status": "active"
    }

    # Serialize state for Terraform
    state_value = state_schema.validate(resource_state)
    return cty_to_msgpack(state_value, state_schema)

# Terraform/Go can deserialize this directly:
# state, err := msgpack.Unmarshal(pythonBytes, stateSchema)
```

## Terraform Provider Development

### Provider Schema Definition

```python
from pyvider.cty import CtyObject, CtyString, CtyNumber, CtyBool, CtyMap

# Define provider configuration schema
provider_config_schema = CtyObject(
    attribute_types={
        "api_token": CtyString(),
        "endpoint": CtyString(),
        "timeout": CtyNumber()
    },
    optional_attributes={"timeout"}
)

# Define resource schemas
resource_schemas = {
    "example_server": CtyObject(
        attribute_types={
            "name": CtyString(),
            "instance_type": CtyString(),
            "region": CtyString(),
            "enabled": CtyBool(),
            "tags": CtyMap(element_type=CtyString())
        },
        optional_attributes={"enabled", "tags"}
    ),

    "example_network": CtyObject(
        attribute_types={
            "cidr": CtyString(),
            "name": CtyString(),
            "subnet_count": CtyNumber()
        }
    )
}
```

### Resource CRUD Operations

```python
class ExampleServerResource:
    """Example Terraform resource implementation."""

    def __init__(self, schema):
        self.schema = schema

    def create(self, config_msgpack):
        """Create resource from Terraform config."""
        # Deserialize config from Terraform
        config = cty_from_msgpack(config_msgpack, self.schema)

        # Extract values
        name = config['name'].raw_value
        instance_type = config['instance_type'].raw_value
        region = config['region'].raw_value

        # Create resource (API calls, etc.)
        resource_id = self._api_create(name, instance_type, region)

        # Build state
        state_data = {
            "name": name,
            "instance_type": instance_type,
            "region": region,
            "enabled": config['enabled'].raw_value if not config['enabled'].is_null else True,
            "tags": config['tags'].raw_value if not config['tags'].is_null else {}
        }

        # Return state as MessagePack
        state_value = self.schema.validate(state_data)
        return cty_to_msgpack(state_value, self.schema)

    def read(self, state_msgpack):
        """Read current resource state."""
        # Deserialize current state
        state = cty_from_msgpack(state_msgpack, self.schema)

        # Fetch current state from API
        current_data = self._api_read(state['name'].raw_value)

        # Validate and serialize
        current_value = self.schema.validate(current_data)
        return cty_to_msgpack(current_value, self.schema)

    def update(self, state_msgpack, config_msgpack):
        """Update resource."""
        state = cty_from_msgpack(state_msgpack, self.schema)
        config = cty_from_msgpack(config_msgpack, self.schema)

        # Determine what changed and update
        # ...

        return self._build_state()

    def delete(self, state_msgpack):
        """Delete resource."""
        state = cty_from_msgpack(state_msgpack, self.schema)
        resource_id = state['name'].raw_value
        self._api_delete(resource_id)
```

### Validation Functions

```python
def validate_cidr_block(value):
    """Custom validation function for CIDR blocks."""
    import ipaddress

    if value.is_null or value.is_unknown:
        return  # Allow null/unknown values

    cidr_string = value.raw_value
    try:
        ipaddress.ip_network(cidr_string)
    except ValueError as e:
        from pyvider.cty.exceptions import CtyValidationError
        raise CtyValidationError(f"Invalid CIDR block: {e}")

# Use in resource validation
def validate_network_config(config):
    """Validate network resource configuration."""
    validated = network_schema.validate(config)

    # Additional custom validation
    validate_cidr_block(validated['cidr'])

    return validated
```

## Working with Terraform State

### Reading State Files

```python
import json
from pyvider.cty.codec import cty_from_msgpack

def read_terraform_state(state_file_path):
    """Read and parse Terraform state file."""
    with open(state_file_path) as f:
        state = json.load(f)

    resources = []
    for resource in state.get("resources", []):
        resource_type = resource["type"]
        resource_mode = resource["mode"]

        for instance in resource.get("instances", []):
            # State is stored as attributes dict
            attributes = instance.get("attributes", {})

            # If you have the schema, validate
            if resource_type in resource_schemas:
                schema = resource_schemas[resource_type]
                validated = schema.validate(attributes)
                resources.append({
                    "type": resource_type,
                    "mode": resource_mode,
                    "value": validated
                })
            else:
                resources.append({
                    "type": resource_type,
                    "mode": resource_mode,
                    "attributes": attributes
                })

    return resources
```

### Modifying State

```python
def update_resource_state(state_file, resource_address, new_attributes):
    """Update a specific resource in state file."""
    with open(state_file) as f:
        state = json.load(f)

    # Find resource
    for resource in state.get("resources", []):
        if resource["type"] == resource_address:
            for instance in resource.get("instances", []):
                # Validate new attributes
                schema = resource_schemas[resource["type"]]
                validated = schema.validate(new_attributes)

                # Update attributes
                instance["attributes"] = new_attributes

    # Write back
    with open(state_file, 'w') as f:
        json.dump(state, f, indent=2)
```

## Variable Validation

### Input Variable Types

```python
# Terraform variable definition:
# variable "vpc_config" {
#   type = object({
#     cidr = string
#     name = string
#     enable_dns = bool
#   })
# }

vpc_var_type = parse_tf_type_to_ctytype("""
    object({
        cidr = string,
        name = string,
        enable_dns = bool
    })
""")

# Validate variable value
vpc_value = vpc_var_type.validate({
    "cidr": "10.0.0.0/16",
    "name": "main-vpc",
    "enable_dns": True
})

# Access validated values
print(vpc_value['cidr'].raw_value)  # "10.0.0.0/16"
```

### Default Values and Null

```python
# Variable with optional attributes
config_type = CtyObject(
    attribute_types={
        "required_field": CtyString(),
        "optional_field": CtyString(),
        "with_default": CtyNumber()
    },
    optional_attributes={"optional_field", "with_default"}
)

# Minimal config
minimal = config_type.validate({"required_field": "value"})

# Optional fields are null
assert minimal['optional_field'].is_null
assert minimal['with_default'].is_null

# Apply defaults
def apply_defaults(value, defaults):
    """Apply default values to null attributes."""
    result = {}
    for attr_name in value.type.attribute_types.keys():
        attr_value = value[attr_name]
        if attr_value.is_null and attr_name in defaults:
            result[attr_name] = defaults[attr_name]
        else:
            result[attr_name] = attr_value.raw_value if not attr_value.is_null else None
    return result

defaults = {"with_default": 42}
final_config = apply_defaults(minimal, defaults)
# {"required_field": "value", "optional_field": None, "with_default": 42}
```

## Module Integration

### Module Input Validation

```python
# Define module interface
module_inputs = {
    "network": parse_tf_type_to_ctytype("""
        object({
            vpc_cidr = string,
            availability_zones = list(string)
        })
    """),
    "compute": parse_tf_type_to_ctytype("""
        object({
            instance_count = number,
            instance_type = string
        })
    """)
}

def validate_module_inputs(inputs):
    """Validate all module inputs."""
    validated = {}
    for input_name, input_schema in module_inputs.items():
        if input_name not in inputs:
            raise ValueError(f"Missing required input: {input_name}")
        validated[input_name] = input_schema.validate(inputs[input_name])
    return validated

# Usage
user_inputs = {
    "network": {
        "vpc_cidr": "10.0.0.0/16",
        "availability_zones": ["us-east-1a", "us-east-1b"]
    },
    "compute": {
        "instance_count": 3,
        "instance_type": "t2.micro"
    }
}

validated_inputs = validate_module_inputs(user_inputs)
```

### Module Output Types

```python
# Define output schema
module_outputs = {
    "vpc_id": CtyString(),
    "subnet_ids": CtyList(element_type=CtyString()),
    "instance_ips": CtyList(element_type=CtyString())
}

def validate_module_outputs(outputs):
    """Validate module outputs match expected types."""
    validated = {}
    for output_name, output_type in module_outputs.items():
        if output_name in outputs:
            validated[output_name] = output_type.validate(outputs[output_name])
    return validated
```

## Unknown and Null Values

Terraform uses special "unknown" values during planning when values aren't computed yet.

### Handling Unknown Values

```python
from pyvider.cty.values import CtyValue

# Create unknown value
unknown_string = CtyValue.unknown(CtyString())

# Check for unknown
if unknown_string.is_unknown:
    print("Value will be computed during apply")

# Validate data with unknown values
config_with_unknown = {
    "name": "server-1",
    "ip_address": None  # Will be unknown
}

# Create schema allowing unknowns
schema = CtyObject(
    attribute_types={
        "name": CtyString(),
        "ip_address": CtyString()
    }
)

# For unknowns, use CtyValue.unknown
from pyvider.cty import CtyObject, CtyString

validated = CtyObject(
    attribute_types={
        "name": CtyString(),
        "ip_address": CtyString()
    }
).validate({
    "name": "server-1",
    "ip_address": None  # Becomes null
})

# To create actual unknowns:
unknown_val = CtyValue.unknown(schema)
```

### Null vs Unknown

```python
# Null: value is explicitly absent
null_value = CtyValue.null(CtyString())
assert null_value.is_null

# Unknown: value exists but isn't computed yet
unknown_value = CtyValue.unknown(CtyString())
assert unknown_value.is_unknown

# Different semantics in Terraform:
# - Null means "no value provided"
# - Unknown means "value not yet computed"
```

## Marks and Sensitive Data

Terraform uses marks to track sensitive data.

### Sensitive Value Handling

```python
from pyvider.cty.marks import CtyMark

# Create sensitive mark
sensitive = CtyMark("sensitive")

# Mark a value as sensitive
password = CtyString().validate("super-secret")
marked_password = password.with_marks({sensitive})

# Check if sensitive
if sensitive in marked_password.marks:
    print("This value is sensitive - do not log!")

# Remove all marks (when safe, returns tuple)
unmarked, removed_marks = marked_password.unmark()
```

### Provider Mark Handling

```python
def handle_sensitive_config(config_value):
    """Process configuration with sensitive values."""
    sensitive_mark = CtyMark("sensitive")

    # Identify sensitive fields
    for attr_name in config_value.type.attribute_types.keys():
        attr_value = config_value[attr_name]

        if sensitive_mark in attr_value.marks:
            # Handle sensitive value - don't log
            print(f"{attr_name}: <sensitive>")
        else:
            # Safe to log
            print(f"{attr_name}: {attr_value.raw_value}")
```

## Best Practices

### 1. Cache Parsed Schemas

```python
# Bad: Parse on every validation
for config in configs:
    schema = parse_tf_type_to_ctytype("object({...})")
    schema.validate(config)

# Good: Parse once, reuse
schema = parse_tf_type_to_ctytype("object({...})")
for config in configs:
    schema.validate(config)
```

### 2. Handle Optional Attributes

```python
# Always specify optional attributes
schema = CtyObject(
    attribute_types={
        "required": CtyString(),
        "optional": CtyString()
    },
    optional_attributes={"optional"}  # Explicit!
)

# Check for null before accessing
value = schema.validate({"required": "value"})
if not value['optional'].is_null:
    print(value['optional'].raw_value)
```

### 3. Validate Early

```python
# Validate at provider boundaries
def create_resource(config_dict):
    # Validate immediately
    config = resource_schema.validate(config_dict)

    # Now work with type-safe values
    name = config['name'].raw_value
    # ...
```

### 4. Use MessagePack for Interop

```python
# Use MessagePack for all Terraform communication
def send_to_terraform(value, schema):
    return cty_to_msgpack(value, schema)

def receive_from_terraform(msgpack_data, schema):
    return cty_from_msgpack(msgpack_data, schema)
```

### 5. Test with Real Terraform Data

```python
# Test your provider with actual Terraform
def test_resource_creation():
    # Load actual Terraform config
    with open("terraform.tfvars.json") as f:
        config = json.load(f)

    # Validate
    validated = resource_schema.validate(config["resource_config"])

    # Test CRUD operations
    state = create_resource(validated)
    # ...
```

## Common Patterns

### Configuration Validator

```python
class TerraformValidator:
    """Validate Terraform configurations."""

    def __init__(self):
        self.schemas = {}

    def register(self, name, type_string):
        """Register a schema."""
        self.schemas[name] = parse_tf_type_to_ctytype(type_string)

    def validate(self, name, data):
        """Validate data against schema."""
        return self.schemas[name].validate(data)

# Usage
validator = TerraformValidator()
validator.register("vpc", "object({cidr=string,name=string})")
vpc = validator.validate("vpc", {"cidr": "10.0.0.0/16", "name": "main"})
```

### Type-Safe State Manager

```python
class StateManager:
    """Manage Terraform state with type safety."""

    def __init__(self, state_file, schemas):
        self.state_file = state_file
        self.schemas = schemas
        self.state = self._load_state()

    def _load_state(self):
        with open(self.state_file) as f:
            return json.load(f)

    def get_resource(self, resource_type, index=0):
        """Get typed resource from state."""
        for resource in self.state.get("resources", []):
            if resource["type"] == resource_type:
                attrs = resource["instances"][index]["attributes"]
                schema = self.schemas[resource_type]
                return schema.validate(attrs)
        return None

    def update_resource(self, resource_type, new_attrs, index=0):
        """Update resource with validation."""
        schema = self.schemas[resource_type]
        validated = schema.validate(new_attrs)

        for resource in self.state.get("resources", []):
            if resource["type"] == resource_type:
                resource["instances"][index]["attributes"] = new_attrs

        self._save_state()

    def _save_state(self):
        with open(self.state_file, 'w') as f:
            json.dump(self.state, f, indent=2)
```

## Further Reading

- **[How to Work with Terraform](../../how-to/work-with-terraform.md)** - Practical examples and patterns
- **[go-cty Comparison](../../reference/go-cty-comparison.md)** - Detailed comparison with Go implementation
- **[Serialization](serialization.md)** - MessagePack encoding/decoding details
- **[Migrate from go-cty](../../how-to/migrate-from-go-cty.md)** - Migration guide for Go developers
>>> EOF >>>

### FILE 39: user-guide/core-concepts/conversion.md | checksum=7ef1aea23be2... | modified=2025-11-15T19:17:59 | op=+ | size=9718 | tokens=2454 | type=markdown ###
<<< BOF <<<
# Type Conversion

Type conversion in pyvider.cty allows you to transform values from one type to another when they are compatible. This is different from validation, which requires exact type matches.

## Conversion vs Validation

**Validation** is strict - it checks that data matches a type exactly:

```python
from pyvider.cty import CtyNumber

number_type = CtyNumber()
number_type.validate("123")  # ‚ùå Raises CtyValidationError
number_type.validate(123)     # ‚úÖ Returns CtyValue(123)
```

**Conversion** is flexible - it transforms values between compatible types:

```python
from pyvider.cty import CtyString, CtyNumber, convert

string_val = CtyString().validate("123")
number_val = convert(string_val, CtyNumber())  # ‚úÖ Converts to number
print(number_val.raw_value)  # 123
```

## The `convert()` Function

The primary interface for conversion is the `convert()` function:

```python
from pyvider.cty import convert

converted_value = convert(source_value, target_type)
```

**Parameters:**
- `source_value`: A `CtyValue` to convert from
- `target_type`: A `CtyType` to convert to

**Returns:**
- A new `CtyValue` of the target type

**Raises:**
- `CtyConversionError` if conversion is not possible

## Conversion Rules

### Primitive Conversions

**String ‚Üí Number**
```python
from pyvider.cty import CtyString, CtyNumber, convert

str_val = CtyString().validate("42.5")
num_val = convert(str_val, CtyNumber())
print(num_val.raw_value)  # Decimal('42.5')
```

**Number ‚Üí String**
```python
num_val = CtyNumber().validate(42)
str_val = convert(num_val, CtyString())
print(str_val.raw_value)  # "42"
```

**Bool ‚Üí String**
```python
from pyvider.cty import CtyBool

bool_val = CtyBool().validate(True)
str_val = convert(bool_val, CtyString())
print(str_val.raw_value)  # "true"
```

**String ‚Üí Bool**
```python
str_val = CtyString().validate("true")
bool_val = convert(str_val, CtyBool())
print(bool_val.raw_value)  # True

# Accepts: "true", "false" (case-insensitive)
# Rejects: Other strings
```

**Number ‚Üí Bool**
```python
# Non-zero ‚Üí True, Zero ‚Üí False
num_val = CtyNumber().validate(1)
bool_val = convert(num_val, CtyBool())
print(bool_val.raw_value)  # True
```

### Collection Conversions

**List ‚Üí Set**
```python
from pyvider.cty import CtyList, CtySet, CtyString

list_val = CtyList(CtyString()).validate(["a", "b", "a"])
set_val = convert(list_val, CtySet(CtyString()))
print(set_val.raw_value)  # {"a", "b"} - duplicates removed
```

**Set ‚Üí List**
```python
set_val = CtySet(CtyString()).validate({"x", "y", "z"})
list_val = convert(set_val, CtyList(CtyString()))
# Order may vary (sets are unordered)
```

**List ‚Üí Tuple**
```python
from pyvider.cty import CtyTuple

list_val = CtyList(CtyString()).validate(["a", "b", "c"])
tuple_val = convert(list_val, CtyTuple([CtyString(), CtyString(), CtyString()]))
```

### Converting to Dynamic

Any type can convert to `CtyDynamic`:

```python
from pyvider.cty import CtyDynamic

string_val = CtyString().validate("hello")
dynamic_val = convert(string_val, CtyDynamic())

# The dynamic value wraps the original type
print(dynamic_val.wrapped_type)  # CtyString
```

### Converting Element Types

Convert collections by converting their elements:

```python
from pyvider.cty import CtyList, CtyString, CtyNumber

# List of strings
str_list = CtyList(CtyString()).validate(["1", "2", "3"])

# Convert to list of numbers
num_list = convert(str_list, CtyList(CtyNumber()))
print(num_list.raw_value)  # [Decimal('1'), Decimal('2'), Decimal('3')]
```

## The `unify()` Function

Type unification finds a common type that can represent multiple types:

```python
from pyvider.cty import unify, CtyString, CtyNumber

# Find common type for string and number
unified_type = unify([CtyString(), CtyNumber()])
print(unified_type)  # CtyDynamic - the most general common type
```

**Use Cases:**
- Merging data from multiple sources
- Finding common type for heterogeneous collections
- Type inference for mixed data

**Examples:**

```python
from pyvider.cty import unify, CtyNumber, CtyBool

# Unify numbers and booleans
result = unify([CtyNumber(), CtyBool()])
# Result: CtyNumber (bools can convert to numbers)

# Unify identical types
result = unify([CtyString(), CtyString()])
# Result: CtyString

# Unify incompatible types
result = unify([CtyString(), CtyNumber(), CtyBool()])
# Result: CtyDynamic (fallback to most general type)
```

## Conversion with Marks

Marks (metadata) are preserved during conversion:

```python
from pyvider.cty.marks import CtyMark

sensitive = CtyMark("sensitive")

# Mark a string value
str_val = CtyString().validate("secret")
marked_str = str_val.with_marks({sensitive})

# Convert to number (marks preserved)
num_val = convert(marked_str, CtyNumber())  # Converts "secret" if numeric
print(sensitive in num_val.marks)  # True - marks preserved
```

## Null and Unknown Values

Conversion behavior with special values:

```python
from pyvider.cty.values import CtyValue

# Null values
null_string = CtyValue.null(CtyString())
null_number = convert(null_string, CtyNumber())
print(null_number.is_null)  # True - nullness preserved

# Unknown values
unknown_string = CtyValue.unknown(CtyString())
unknown_number = convert(unknown_string, CtyNumber())
print(unknown_number.is_unknown)  # True - unknown status preserved
```

## Error Handling

Conversions can fail:

```python
from pyvider.cty.exceptions import CtyConversionError

try:
    # Can't convert non-numeric string to number
    str_val = CtyString().validate("hello")
    num_val = convert(str_val, CtyNumber())
except CtyConversionError as e:
    print(f"Conversion failed: {e}")
    # Conversion failed: Cannot convert "hello" to CtyNumber
```

Common conversion failures:
- String to Number: Non-numeric strings
- String to Bool: Strings other than "true"/"false"
- List to Tuple: Length mismatch
- Object to Object: Missing required attributes

## Type Inference

Infer cty types from raw Python data:

```python
from pyvider.cty.conversion import infer_cty_type_from_raw

# Infer from primitive
inferred = infer_cty_type_from_raw("hello")
print(inferred)  # CtyString

# Infer from list
inferred = infer_cty_type_from_raw([1, 2, 3])
print(inferred)  # CtyList(element_type=CtyNumber)

# Infer from dict
inferred = infer_cty_type_from_raw({"name": "Alice", "age": 30})
print(inferred)  # CtyObject with inferred attributes
```

**Type Inference Rules:**

1. **Primitives**: Direct mapping (str ‚Üí CtyString, int ‚Üí CtyNumber, etc.)
2. **Lists**: Infers element type from first element or uses CtyDynamic for mixed types
3. **Dicts with string keys**: CtyObject (if all keys are valid identifiers) or CtyMap
4. **Dicts with non-string keys**: CtyMap
5. **Sets**: CtySet with inferred element type
6. **Tuples**: CtyTuple with per-element types
7. **None**: CtyDynamic

**Inference Caching:**

Type inference can be expensive. Use caching for repeated inference:

```python
from pyvider.cty.conversion import InferenceCacheContext

with InferenceCacheContext():
    # Repeated inference uses cache
    for data in large_dataset:
        schema = infer_cty_type_from_raw(data)
        validated = schema.validate(data)
```

## Conversion Best Practices

### 1. Prefer Explicit Schemas

Use `convert()` for known conversions, not as a substitute for proper schemas:

```python
# ‚úÖ GOOD: Define explicit schema
config_schema = CtyObject(
    attribute_types={
        "timeout": CtyNumber(),
        "retries": CtyNumber()
    }
)
config = config_schema.validate(raw_data)

# ‚ùå AVOID: Over-reliance on conversion
config = infer_cty_type_from_raw(raw_data).validate(raw_data)
```

### 2. Handle Conversion Errors

Always handle potential conversion failures:

```python
def safe_convert(value, target_type):
    """Convert with error handling."""
    try:
        return convert(value, target_type)
    except CtyConversionError as e:
        logger.warning(f"Conversion failed: {e}")
        return None
```

### 3. Document Conversion Requirements

Make it clear when conversion is necessary:

```python
def process_config(config_data: dict) -> CtyValue:
    """Process configuration data.

    Args:
        config_data: Raw configuration (may have string numbers)

    Returns:
        Validated and converted configuration

    Note:
        Numeric config values provided as strings will be
        automatically converted to numbers.
    """
    raw_config = config_schema.validate(config_data)
    # Convert string numbers to actual numbers if needed
    return convert(raw_config, normalized_config_schema)
```

### 4. Use Type Unification Carefully

Unification to `CtyDynamic` loses type safety:

```python
# ‚ö†Ô∏è Use with caution
unified = unify([CtyString(), CtyNumber(), CtyBool()])
# Result: CtyDynamic - lost all type specificity

# ‚úÖ Better: Find more specific common type if possible
unified = unify([CtyNumber(), CtyBool()])
# Result: CtyNumber - more specific, maintains some type safety
```

## Performance Considerations

Conversion has computational cost:

1. **Type checking** - Validates source and target compatibility
2. **Value transformation** - Creates new immutable values
3. **Deep conversion** - Converts nested structures recursively

For performance-critical paths:

```python
# Convert once, reuse many times
converted_config = convert(raw_config, target_schema)

for _ in range(1000):
    # Use converted value without reconverting
    process(converted_config)
```

## See Also

- **[Validation](validation.md)** - Strict type checking
- **[API: Conversion](../../api/conversion.md)** - Conversion API reference
- **[Type Reference](../type-reference/primitives.md)** - All available types
>>> EOF >>>

### FILE 40: user-guide/core-concepts/types.md | checksum=ec3b4342bfbf... | modified=2025-11-15T19:17:59 | op=+ | size=3203 | tokens=742 | type=markdown ###
<<< BOF <<<
# Understanding Types

In `pyvider.cty`, types are the cornerstone of the entire system. They define the structure, constraints, and expectations for your data. By creating precise type definitions, you can ensure that your data is valid and consistent.

## The Role of Types

A `pyvider.cty` type serves several key purposes:

1.  **Validation**: A type acts as a schema against which you can validate raw Python data. It enforces the structure and types of the data, ensuring that it conforms to your expectations.

2.  **Immutability**: When you validate raw data against a type, you get back an immutable `cty` value. This means that once a value is created, it cannot be changed, which helps to prevent bugs and makes your code more predictable.

3.  **Type-Safe Operations**: `pyvider.cty` provides a set of built-in functions that operate on `cty` values. These functions are type-safe, meaning that they will only work with the correct types of values.

## The `CtyType` Base Class

All `pyvider.cty` types inherit from the `CtyType` base class. This class provides the common interface for all types, including the `validate` method.

### The `validate` Method

The `validate` method is the most important method of a `cty` type. It takes a raw Python value as input and attempts to convert it into a `cty` value of the corresponding type.

```python
cty_value = my_type.validate(raw_python_value)
```

If the validation is successful, `validate` returns a new `cty` value. If the validation fails, it raises a `ValidationError` with detailed information about what went wrong.

## Categories of Types

`pyvider.cty` provides a rich set of built-in types that can be divided into three main categories:

1.  **Primitive Types**: These are the basic building blocks of the type system. They represent simple, single values.
    *   `CtyString`: Represents a string of text.
    *   `CtyNumber`: Represents a number (integer or float).
    *   `CtyBool`: Represents a boolean value (`True` or `False`).

2.  **Collection Types**: These types represent collections of other types.
    *   `CtyList`: Represents a list of elements of the same type.
    *   `CtySet`: Represents a set of unique elements of the same type.
    *   `CtyMap`: Represents a map of key-value pairs, where the keys are strings and the values are all of the same type.

3.  **Structural Types**: These types represent more complex, structured data.
    *   `CtyObject`: Represents an object with a fixed set of named attributes, each with its own type.
    *   `CtyTuple`: Represents a sequence of elements with a fixed length, where each element can have a different type.

In the following chapters, we will explore each of these categories in more detail.

## See Also

- **[Type Reference: Primitives](../type-reference/primitives.md)** - Detailed guide to String, Number, and Bool types
- **[Type Reference: Collections](../type-reference/collections.md)** - Working with List, Map, and Set
- **[Type Reference: Structural](../type-reference/structural.md)** - Object and Tuple types
- **[Working with Values](values.md)** - Understanding CtyValue objects
- **[Validation](validation.md)** - How type validation works
>>> EOF >>>

### FILE 41: user-guide/core-concepts/validation.md | checksum=cc3663c46d37... | modified=2025-11-15T19:17:59 | op=+ | size=8770 | tokens=2062 | type=markdown ###
<<< BOF <<<
# Validation

Validation is the process of checking whether raw Python data conforms to a defined type schema. In pyvider.cty, validation is the gateway between untrusted or untyped data and type-safe `CtyValue` objects.

## How Validation Works

Every `CtyType` provides a `validate()` method that:

1. **Accepts raw Python data** (dicts, lists, primitives, etc.)
2. **Checks conformance** against the type schema
3. **Returns a CtyValue** if valid
4. **Raises a CtyValidationError** if invalid

```python
from pyvider.cty import CtyString, CtyValidationError

string_type = CtyString()

# Valid: returns CtyValue
result = string_type.validate("hello")
print(result.raw_value)  # "hello"

# Invalid: raises CtyValidationError
try:
    string_type.validate(123)
except CtyValidationError as e:
    print(f"Error: {e}")  # Error: expected CtyString, got int
```

## Validation vs Direct Construction

You should always prefer `validate()` over direct `CtyValue` construction:

```python
# ‚úÖ RECOMMENDED: Use validate()
value = CtyString().validate("hello")

# ‚ùå AVOID: Direct construction (internal API)
# from pyvider.cty.values import CtyValue
# value = CtyValue(...)  # Don't do this!
```

The `validate()` method provides:
- Type checking and coercion
- Clear error messages
- Consistent behavior across all types
- Protection against malformed data

## Validation Rules by Type

### Primitives

**CtyString**
- Accepts: `str` values
- Rejects: Non-string types
- Special handling: Unicode normalization (NFC)

**CtyNumber**
- Accepts: `int`, `float`, `Decimal`
- Rejects: Non-numeric types
- Special handling: Preserves precision with `Decimal`

**CtyBool**
- Accepts: `bool` values (`True`, `False`)
- Rejects: Non-boolean types (including truthy/falsy values like `1`, `0`, `""`)

### Collections

**CtyList**
- Accepts: `list` or other iterables
- Element validation: Each element must match `element_type`
- Preserves: Order

**CtySet**
- Accepts: `set`, `frozenset`, or iterables
- Element validation: Each element must match `element_type`
- Removes: Duplicates (enforces set semantics)

**CtyMap**
- Accepts: `dict` with string keys
- Element validation: All values must match `element_type`
- Key requirement: Keys must be strings

### Structural Types

**CtyObject**
- Accepts: `dict` with specific attributes
- Attribute validation: Each attribute validated against its type
- Optional attributes: Missing optional attributes become null values
- Required attributes: Must be present (unless optional)

**CtyTuple**
- Accepts: `list`, `tuple`, or iterables
- Element validation: Each position validated against its element type
- Length requirement: Must match declared element count

## Recursive Validation

Validation works recursively through nested structures:

```python
from pyvider.cty import CtyObject, CtyList, CtyString, CtyNumber

# Nested schema
company_type = CtyObject(
    attribute_types={
        "name": CtyString(),
        "employees": CtyList(
            element_type=CtyObject(
                attribute_types={
                    "name": CtyString(),
                    "salary": CtyNumber()
                }
            )
        )
    }
)

# Validation descends through the structure
company_data = {
    "name": "Acme Corp",
    "employees": [
        {"name": "Alice", "salary": 100000},
        {"name": "Bob", "salary": 95000}
    ]
}

company = company_type.validate(company_data)
# If Bob's salary was "95000" (string), validation would fail
# at the path: employees[1].salary
```

## Validation Context and Depth Limits

pyvider.cty tracks validation depth to prevent infinite recursion:

```python
from pyvider.cty.context import deeper_validation, MAX_VALIDATION_DEPTH

# Context tracks current validation depth
with deeper_validation():
    # Validation depth increased by 1
    pass

# Maximum depth: 500 (configurable via MAX_VALIDATION_DEPTH)
```

This protection prevents stack overflow with:
- Circular references (if raw data contains them)
- Extremely deep nesting
- Malicious input designed to cause resource exhaustion

## Error Handling

Validation errors provide detailed context:

```python
from pyvider.cty import CtyObject, CtyString, CtyNumber
from pyvider.cty.exceptions import CtyAttributeValidationError

user_type = CtyObject(
    attribute_types={
        "name": CtyString(),
        "age": CtyNumber()
    }
)

try:
    user_type.validate({
        "name": "Alice",
        "age": "thirty"  # Wrong type!
    })
except CtyAttributeValidationError as e:
    print(e.attribute_name)  # "age"
    print(e.path)            # Path to error location
    print(e)                 # Full error message
```

### Exception Hierarchy

```
CtyValidationError (base)
‚îú‚îÄ‚îÄ CtyTypeMismatchError
‚îú‚îÄ‚îÄ CtyAttributeValidationError
‚îú‚îÄ‚îÄ CtyListValidationError
‚îú‚îÄ‚îÄ CtyMapValidationError
‚îú‚îÄ‚îÄ CtySetValidationError
‚îî‚îÄ‚îÄ CtyTupleValidationError
```

Catch specific exceptions for targeted error handling:

```python
try:
    value = schema.validate(data)
except CtyAttributeValidationError as e:
    # Handle object attribute errors
    log.error(f"Attribute {e.attribute_name} is invalid")
except CtyListValidationError as e:
    # Handle list validation errors
    log.error(f"List validation failed at index {e.index}")
except CtyValidationError as e:
    # Catch-all for other validation errors
    log.error(f"Validation failed: {e}")
```

## Validation Best Practices

### 1. Validate at System Boundaries

Always validate data when it enters your system:

```python
def handle_api_request(request_data):
    """Validate incoming API data."""
    try:
        validated = request_schema.validate(request_data)
        return process_request(validated)
    except CtyValidationError as e:
        return {"error": str(e)}, 400
```

### 2. Use Specific Error Handling

Catch specific validation errors for better error messages:

```python
try:
    config = config_schema.validate(raw_config)
except CtyAttributeValidationError as e:
    print(f"Invalid configuration: {e.attribute_name} is incorrect")
except CtyValidationError as e:
    print(f"Configuration validation failed: {e}")
```

### 3. Build Schemas Incrementally

Define sub-schemas and compose them:

```python
# Define reusable schemas
address_type = CtyObject(
    attribute_types={
        "street": CtyString(),
        "city": CtyString(),
        "zip": CtyString()
    }
)

# Compose into larger schemas
person_type = CtyObject(
    attribute_types={
        "name": CtyString(),
        "address": address_type  # Reuse
    }
)
```

### 4. Document Optional Fields

Make it clear which fields are optional:

```python
# Clear documentation of optional fields
user_type = CtyObject(
    attribute_types={
        "username": CtyString(),  # Required
        "email": CtyString(),      # Required
        "phone": CtyString(),      # Optional
        "bio": CtyString()         # Optional
    },
    optional_attributes={"phone", "bio"}
)
```

### 5. Test Edge Cases

Test validation with edge cases:

```python
def test_user_validation():
    """Test user validation with various inputs."""
    # Test valid data
    valid_user = user_type.validate({"username": "alice", "email": "a@ex.com"})
    assert valid_user is not None

    # Test missing required field
    with pytest.raises(CtyValidationError):
        user_type.validate({"username": "bob"})  # Missing email

    # Test wrong type
    with pytest.raises(CtyValidationError):
        user_type.validate({"username": 123, "email": "a@ex.com"})
```

## Performance Considerations

Validation has computational cost:

1. **Type checking** - Every value is type-checked
2. **Recursion** - Nested structures validated recursively
3. **Immutable construction** - Creates new immutable values

For performance-critical paths:

```python
# Validate once at the boundary
config = config_schema.validate(raw_config)

# Reuse the validated value
for _ in range(1000):
    # Don't validate again inside the loop
    process(config)
```

## Integration with Type Conversion

Validation and type conversion work together:

```python
from pyvider.cty import convert, CtyString, CtyNumber

# Validation: Strict type checking
number_type = CtyNumber()
number_type.validate("123")  # ‚ùå Raises error: expected number, got str

# Conversion: Flexible type transformation
string_val = CtyString().validate("123")
number_val = convert(string_val, CtyNumber())  # ‚úÖ Converts "123" to 123
```

## See Also

- **[Type Conversion](../../api/conversion.md)** - Converting between types
- **[How-To: Validate Data](../../how-to/validate-data.md)** - Practical validation patterns
- **[Error Handling](../../reference/troubleshooting.md)** - Handling validation errors
>>> EOF >>>

### FILE 42: user-guide/core-concepts/values.md | checksum=44bb2fc2cadc... | modified=2025-10-24T20:50:19 | op=+ | size=5184 | tokens=1195 | type=markdown ###
<<< BOF <<<
# Working with Values

In `pyvider.cty`, a "value" is an instance of a `cty` type. Values are the lifeblood of the `cty` system, as they hold the actual data that you work with.

## The `CtyValue` Class

All `pyvider.cty` values are instances of the `CtyValue` class. This class provides the common interface for all values, including methods for accessing the raw data and performing type-safe operations.

### Accessing the Raw Value

You can access the underlying, native Python representation of a `cty` value using the `.raw_value` property:

```python
from pyvider.cty import CtyString

string_val = CtyString().validate("hello")
raw_string = string_val.raw_value

assert raw_string == "hello"
```

### Immutability

One of the key features of `cty` values is that they are **immutable**. This means that once a value is created, it cannot be changed. This has several advantages:

*   **Predictability**: It makes your code more predictable, as you can be sure that a value will not change unexpectedly.
*   **Safety**: It helps to prevent bugs caused by unintended side effects.
*   **Concurrency**: It makes it easier to write concurrent code, as you don't have to worry about race conditions when accessing values.

## Special Values: Null and Unknown

In addition to regular values, `pyvider.cty` has two special kinds of values:

1.  **Null Values**: A null value represents the explicit absence of a value.
2.  **Unknown Values**: An unknown value represents a value that is not yet known but will be populated later.

You can create these using the class methods on `CtyValue`:

```python
from pyvider.cty import CtyObject, CtyString, CtyNumber, CtyValue

# 1. Define a user profile type.
profile_type = CtyObject(
    attribute_types={
        "username": CtyString(),
        "age": CtyNumber(),
    },
)

# 2. Create an unknown value of the profile type.
# This represents a value that will be known later (e.g., after an API call).
unknown_value = CtyValue.unknown(profile_type)

# 3. Create a null value of the profile type.
# This represents an explicit absence of a value.
null_value = CtyValue.null(profile_type)

# 4. Check the state of each value.
print(f"Unknown Value: Is Unknown? {unknown_value.is_unknown}, Is Null? {unknown_value.is_null}")
print(f"Null Value:    Is Unknown? {null_value.is_unknown}, Is Null? {null_value.is_null}")

# Accessing properties of a null or unknown value would raise an error.
try:
    _ = null_value["username"]
except TypeError as e:
    print(f"Attempting to access null value property failed as expected: {e}")
```

### Refined Unknown Values

`pyvider.cty` supports **refined unknowns**, which are unknown values that carry additional refinement information. This feature is particularly useful in scenarios like Terraform planning, where you know that a value will be computed later but can provide constraints about what that value will be.

Refined unknowns allow you to specify partial information about an unknown value, such as:
- Range constraints for numbers
- String prefix/suffix constraints
- Collection length constraints

```python
from pyvider.cty.values import UnknownValue, RefinedUnknownValue
from pyvider.cty import CtyNumber, CtyString

# Create a basic unknown value
basic_unknown = UnknownValue(CtyNumber())
print(f"Basic unknown: {basic_unknown.is_unknown}")  # True

# Create a refined unknown value (advanced usage)
# Note: RefinedUnknownValue is typically used internally by the type system
# or in advanced scenarios like Terraform provider development
refined_unknown = RefinedUnknownValue(
    vtype=CtyNumber(),
    refinement=None  # Refinement constraints (implementation-specific)
)
```

**When to use refined unknowns:**
- **Terraform providers**: During the plan phase when values will be known during apply
- **Validation**: When you need to validate that constraints will be satisfied even though the actual value is unknown
- **Type propagation**: In function implementations where unknowns need to propagate with refinements

**Note**: Most users will work with regular unknown values via `CtyValue.unknown()`. Refined unknowns are an advanced feature primarily used in infrastructure-as-code scenarios and by library implementers.

## Immutable Updates with Helper Methods

Since `CtyValue` objects are immutable, you create modified versions instead of changing them in-place. `pyvider.cty` provides convenient helper methods on collection values for this purpose.

```python
from pyvider.cty import CtyMap, CtyNumber

# 1. Define a map type and create an initial CtyValue.
config_type = CtyMap(element_type=CtyNumber())
config_val = config_type.validate({"timeout": 30})

# 2. Use .with_key() to add/update an element, returning a NEW value.
new_config_val = config_val.with_key("batch_size", 500).with_key("timeout", 60)

# 3. Use .without_key() to remove an element, returning a NEW value.
final_config_val = new_config_val.without_key("timeout")

print(f"Original: {config_val.raw_value}")
print(f"Updated:  {new_config_val.raw_value}")
print(f"Final:    {final_config_val.raw_value}")
```

Similar methods like `.append()` and `.with_element_at()` exist for `CtyList` values.
>>> EOF >>>

### FILE 43: user-guide/index.md | checksum=425e817ffe70... | modified=2025-11-15T19:17:59 | op=+ | size=2075 | tokens=476 | type=markdown ###
<<< BOF <<<
# User Guide

Welcome to the pyvider.cty User Guide. This comprehensive guide covers all features of the library in depth.

## Guide Structure

The user guide is organized into three main sections:

### Core Concepts

Fundamental concepts you need to understand:

- **[Understanding Types](core-concepts/types.md)** - The type system architecture
- **[Working with Values](core-concepts/values.md)** - Value objects and immutability
- **[Validation](core-concepts/validation.md)** - How validation works
- **[Type Conversion](core-concepts/conversion.md)** - Converting between types

### Type Reference

Detailed documentation for each type:

- **[Primitive Types](type-reference/primitives.md)** - String, Number, Bool
- **[Collection Types](type-reference/collections.md)** - List, Map, Set
- **[Structural Types](type-reference/structural.md)** - Object, Tuple
- **[Dynamic Types](type-reference/dynamic.md)** - Runtime type determination
- **[Capsule Types](type-reference/capsule.md)** - Opaque data containers

### Advanced Topics

Advanced features and use cases:

- **[Marks System](advanced/marks.md)** - Attach metadata to values
- **[Built-in Functions](advanced/functions.md)** - Standard library functions
- **[Serialization](advanced/serialization.md)** - MessagePack encoding/decoding
- **[Path Navigation](advanced/path-navigation.md)** - Navigate nested structures
- **[Terraform Interoperability](advanced/terraform-interop.md)** - Work with Terraform

## How to Use This Guide

- **If you're new**: Start with Core Concepts, then explore Type Reference
- **If you need a refresher**: Jump to the specific type or feature you're interested in
- **If you're solving a problem**: Check the [How-To Guides](../how-to/index.md) first

## Other Resources

- **[Getting Started](../getting-started/index.md)** - Quick introduction
- **[How-To Guides](../how-to/index.md)** - Task-oriented guides
- **[API Reference](../api/index.md)** - Complete API documentation
- **[Reference](../reference/troubleshooting.md)** - Troubleshooting, configuration, and glossary
>>> EOF >>>

### FILE 44: user-guide/type-reference/capsule.md | checksum=d6f38a46c4d0... | modified=2025-11-15T19:17:59 | op=+ | size=2016 | tokens=486 | type=markdown ###
<<< BOF <<<
# Capsule Types

The `CtyCapsule` type is a special type in `pyvider.cty` that allows you to encapsulate and protect foreign data types within the `cty` system. This is useful when you need to work with data that cannot be represented by the standard `cty` types, such as file handles, database connections, or other external resources.

## The `CtyCapsule` Type

To create a `CtyCapsule` type, you must provide a name for the type:

```python
from pyvider.cty import CtyCapsule

file_handle_type = CtyCapsule("FileHandle")
```

This creates a new `CtyCapsule` type that can be used to encapsulate file handle objects.

## Encapsulating and Accessing Data

You can encapsulate a foreign data type in a `CtyCapsule` value using the `validate` method:

```python
# Create a dummy file handle object
class FileHandle:
    def __init__(self, path):
        self.path = path

file_handle = FileHandle("/path/to/file")

# Encapsulate the file handle in a CtyCapsule value
cty_file_handle = file_handle_type.validate(file_handle)
```

You can then access the encapsulated object using the `raw_value` property:

```python
encapsulated_handle = cty_file_handle.raw_value
assert encapsulated_handle.path == "/path/to/file"
```

## Type Safety

`CtyCapsule` types are type-safe. This means that you can only encapsulate objects of the correct type in a `CtyCapsule` value.

```python
# This will raise a ValidationError
try:
    file_handle_type.validate("not a file handle")
except Exception as e:
    print(f"Validation failed: {e}")
```

This type safety ensures that you can't accidentally mix up different types of encapsulated data.

## See Also

- **[Understanding Types](../core-concepts/types.md)** - Core type system concepts
- **[Create Custom Types](../../how-to/create-custom-types.md)** - Building custom type wrappers
- **[Serialization](../advanced/serialization.md)** - Capsule serialization considerations
- **[API Reference: Capsule Types](../../api/types/capsule.md)** - Complete capsule API documentation
>>> EOF >>>

### FILE 45: user-guide/type-reference/collections.md | checksum=942525cf6894... | modified=2025-11-15T19:17:59 | op=+ | size=3031 | tokens=798 | type=markdown ###
<<< BOF <<<
# Collection Types

Collection types represent collections of other types. They allow you to group multiple values together into a single, cohesive unit.

There are three collection types in `pyvider.cty`:

*   `CtyList`: Represents a list of elements of the same type.
*   `CtySet`: Represents a set of unique elements of the same type.
*   `CtyMap`: Represents a map of key-value pairs, where the keys are strings and the values are all of the same type.

## `CtyList`

The `CtyList` type represents a list of elements, where all elements are of the same type.

To create a `CtyList` type, you must specify the type of the elements in the list:

```python
from pyvider.cty import CtyList, CtyString

string_list_type = CtyList(element_type=CtyString())

# Validate a valid list of strings
cty_list = string_list_type.validate(["a", "b", "c"])

# Note: raw_value returns a tuple for immutability
assert cty_list.raw_value == ("a", "b", "c")
assert isinstance(cty_list.raw_value, tuple)

# Validate a list with an invalid element (will raise a ValidationError)
try:
    string_list_type.validate(["a", "b", 123])
except Exception as e:
    print(f"Validation failed: {e}")
```

## `CtySet`

The `CtySet` type represents a set of unique elements of the same type. Like `CtyList`, you must specify the element type when creating a `CtySet` type.

```python
from pyvider.cty import CtySet, CtyNumber

number_set_type = CtySet(element_type=CtyNumber())

# Validate a valid set of numbers
cty_set = number_set_type.validate({1, 2, 3})
assert sorted(list(cty_set.raw_value)) == [1, 2, 3]

# Validate a set with duplicate elements (will be silently deduplicated)
cty_set_dedup = number_set_type.validate({1, 2, 2, 3})
assert sorted(list(cty_set_dedup.raw_value)) == [1, 2, 3]

# Validate a set with an invalid element (will raise a ValidationError)
try:
    number_set_type.validate({1, 2, "c"})
except Exception as e:
    print(f"Validation failed: {e}")
```

## `CtyMap`

The `CtyMap` type represents a map of key-value pairs, where the keys are strings and the values are all of the same type.

To create a `CtyMap` type, you must specify the type of the values in the map:

```python
from pyvider.cty import CtyMap, CtyBool

bool_map_type = CtyMap(element_type=CtyBool())

# Validate a valid map of booleans
cty_map = bool_map_type.validate({"a": True, "b": False})
assert cty_map.raw_value == {"a": True, "b": False}

# Validate a map with an invalid value (will raise a ValidationError)
try:
    bool_map_type.validate({"a": True, "b": 123})
except Exception as e:
    print(f"Validation failed: {e}")
```

## See Also

- **[Understanding Types](../core-concepts/types.md)** - Core type system concepts
- **[Primitive Types](primitives.md)** - String, Number, and Bool types
- **[Structural Types](structural.md)** - Object and Tuple types
- **[Collection Functions](../advanced/functions.md)** - Built-in functions for working with collections
- **[Validation](../core-concepts/validation.md)** - Understanding validation behavior
>>> EOF >>>

### FILE 46: user-guide/type-reference/dynamic.md | checksum=73cacafb8695... | modified=2025-11-15T19:17:59 | op=+ | size=2243 | tokens=549 | type=markdown ###
<<< BOF <<<
# Dynamic Types

The `CtyDynamic` type is a special type in `pyvider.cty` that can represent any type of value. It is useful when you are working with data that has an unknown or varying structure.

## The `CtyDynamic` Type

When you validate a value against a `CtyDynamic` type, the resulting `cty` value will have the most specific type that can be inferred from the raw Python value.

```python
from pyvider.cty import CtyDynamic, CtyString, CtyNumber

dynamic_type = CtyDynamic()

# Validate a string
cty_string = dynamic_type.validate("hello")
# The resulting value is a CtyDynamic that wraps a CtyString
assert isinstance(cty_string.value.type, CtyString)

# Validate a number
cty_number = dynamic_type.validate(123)
assert isinstance(cty_number.value.type, CtyNumber)
```

## `CtyDynamic` in Collections

You can also use the `CtyDynamic` type within collection and structural types. This is powerful for creating flexible data structures.

### Example: Tuple with a Dynamic Element

Here we define a tuple where the last element can be of any type.

```python
from pyvider.cty import CtyDynamic, CtyNumber, CtyObject, CtyString, CtyTuple

# 1. Define a tuple type with a dynamic last element.
coordinate_type = CtyTuple(
    element_types=(CtyString(), CtyNumber(), CtyNumber(), CtyDynamic())
)

# 2. Create raw data that matches the tuple's structure.
point_data = ("GPS", 37.7749, -122.4194, {"accuracy": 10})

# 3. Validate the data.
validated_tuple = coordinate_type.validate(point_data)

# 4. Access the dynamic element.
# CtyDynamic.validate infers the most specific type, which is CtyObject here.
metadata_val = validated_tuple
print(f"Metadata Type (inferred): {metadata_val.value.type}")
print(f"Metadata is an object: {isinstance(metadata_val.value.type, CtyObject)}")
print(f"Metadata accuracy: {metadata_val.value['accuracy'].raw_value}")
```

## See Also

- **[Understanding Types](../core-concepts/types.md)** - Core type system concepts
- **[Structural Types](structural.md)** - Object and Tuple types that can contain dynamic elements
- **[Type Conversion](../core-concepts/conversion.md)** - Understanding type inference and conversion
- **[Validation](../core-concepts/validation.md)** - How dynamic validation works
>>> EOF >>>

### FILE 47: user-guide/type-reference/primitives.md | checksum=a432db17abb3... | modified=2025-11-15T19:17:59 | op=+ | size=2172 | tokens=548 | type=markdown ###
<<< BOF <<<
# Primitive Types

Primitive types are the most basic building blocks of the `pyvider.cty` type system. They represent simple, single values.

There are three primitive types in `pyvider.cty`:

*   `CtyString`: Represents a string of text.
*   `CtyNumber`: Represents a number (integer or float).
*   `CtyBool`: Represents a boolean value (`True` or `False`).

## `CtyString`

The `CtyString` type represents a string of text. You can create a `CtyString` type and use it to validate raw Python strings:

```python
from pyvider.cty import CtyString

string_type = CtyString()

# Validate a valid string
cty_string = string_type.validate("hello")
assert cty_string.raw_value == "hello"

# Validate an invalid value (will raise a ValidationError)
try:
    string_type.validate(123)
except Exception as e:
    print(f"Validation failed: {e}")
```

## `CtyNumber`

The `CtyNumber` type represents a number. It can be an integer or a float.

```python
from pyvider.cty import CtyNumber

number_type = CtyNumber()

# Validate a valid integer
cty_int = number_type.validate(123)
assert cty_int.raw_value == 123

# Validate a valid float
cty_float = number_type.validate(3.14)
assert cty_float.raw_value == 3.14

# Validate an invalid value (will raise a ValidationError)
try:
    number_type.validate("hello")
except Exception as e:
    print(f"Validation failed: {e}")
```

## `CtyBool`

The `CtyBool` type represents a boolean value (`True` or `False`).

```python
from pyvider.cty import CtyBool

bool_type = CtyBool()

# Validate a valid boolean
cty_true = bool_type.validate(True)
assert cty_true.raw_value is True

# Validate an invalid value (will raise a ValidationError)
try:
    bool_type.validate(1)
except Exception as e:
    print(f"Validation failed: {e}")
```

## See Also

- **[Understanding Types](../core-concepts/types.md)** - Core type system concepts
- **[Collection Types](collections.md)** - List, Map, and Set types
- **[Structural Types](structural.md)** - Object and Tuple types
- **[String Functions](../advanced/functions.md)** - Built-in string manipulation functions
- **[Numeric Functions](../advanced/functions.md)** - Built-in numeric operations
>>> EOF >>>

### FILE 48: user-guide/type-reference/structural.md | checksum=e1ce0b7fa76b... | modified=2025-11-15T19:17:59 | op=+ | size=3415 | tokens=807 | type=markdown ###
<<< BOF <<<
# Structural Types

Structural types represent more complex, structured data. They allow you to define the shape and layout of your data with a high degree of precision.

There are two structural types in `pyvider.cty`:

*   `CtyObject`: Represents an object with a fixed set of named attributes, each with its own type.
*   `CtyTuple`: Represents a sequence of elements with a fixed length, where each element can have a different type.

## `CtyObject`

The `CtyObject` type represents an object with a fixed set of named attributes. Each attribute has its own type, which you must specify when creating the `CtyObject` type.

### Syntax Options

`CtyObject` supports two equivalent syntaxes for defining attribute types:

```python
# Explicit syntax (recommended for clarity and consistency)
user_type = CtyObject(
    attribute_types={"name": CtyString(), "age": CtyNumber()},
    optional_attributes={"age"}
)

# Shorthand syntax (also supported)
user_type = CtyObject({"name": CtyString(), "age": CtyNumber()})
```

Both syntaxes are valid, but the explicit `attribute_types=` parameter is recommended for consistency and clarity across your codebase. Use the shorthand syntax only when appropriate for your team's coding standards.

### Optional Attributes

You can also define certain attributes as optional. If an optional attribute is missing from the input data during validation, it will be present in the resulting `CtyValue` as a `null` value of the correct type.

```python
from pyvider.cty import CtyObject, CtyString, CtyNumber, CtyBool

# Define a schema with 'is_active' as an optional attribute
user_type = CtyObject(
    attribute_types={
        "name": CtyString(),
        "age": CtyNumber(),
        "is_active": CtyBool(),
    },
    optional_attributes={"is_active"}
)

# Validate data where the optional attribute is missing
user_data = {"name": "Alice", "age": 30}
cty_user = user_type.validate(user_data)

# Accessing the missing optional attribute returns a null value
active_val = cty_user["is_active"]
print(f"Active: {active_val.raw_value} (Is Null: {active_val.is_null})")

# Validation fails for missing required attributes or extra attributes
try:
    user_type.validate({"name": "Bob"}) # Missing 'age'
except Exception as e:
    print(f"\nValidation failed as expected: {e}")
```

## `CtyTuple`

The `CtyTuple` type represents a sequence of elements with a fixed length, where each element can have a different type.

```python
from pyvider.cty import CtyTuple, CtyString, CtyNumber, CtyBool

tuple_type = CtyTuple(element_types=(
    CtyString(),
    CtyNumber(),
    CtyBool(),
))

# Validate a valid tuple
tuple_data = ["hello", 123, True]
cty_tuple = tuple_type.validate(tuple_data)
assert cty_tuple.raw_value == ("hello", 123, True)

# Validate a tuple with the wrong number of elements (will raise a ValidationError)
try:
    tuple_type.validate(["hello", 123])
except Exception as e:
    print(f"Validation failed as expected: {e}")
```

## See Also

- **[Understanding Types](../core-concepts/types.md)** - Core type system concepts
- **[Collection Types](collections.md)** - List, Map, and Set types
- **[Dynamic Types](dynamic.md)** - Using dynamic types within structures
- **[Path Navigation](../advanced/path-navigation.md)** - Navigating nested structures
- **[Terraform Interoperability](../advanced/terraform-interop.md)** - Working with Terraform object types
>>> EOF >>>


### BUNDLE SUMMARY ###
- Included Files: 48
- Total Size (Included): 288165 bytes
- Duplicate Files Skipped: 0
- Items Excluded by Config/Defaults: 0 (Files: 0, Dirs: 0)
- Empty Files Found: 0
- System Errors Encountered: 0
- Encoding Errors (Fallback Attempted): 0
- Estimated Bundle Token Range: 70008 - 73180
- Processing Time: 0.18 seconds
### END BUNDLE SUMMARY ###

--- END OF BFILE bf-20251129-152706.txt ---
